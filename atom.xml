<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>些许流年</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiexuliunian.github.io/"/>
  <updated>2019-03-01T14:31:02.300Z</updated>
  <id>http://xiexuliunian.github.io/</id>
  
  <author>
    <name>ZXD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>faster rcnn重读记录</title>
    <link href="http://xiexuliunian.github.io/2019/02/27/faster-rcnn%E9%87%8D%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://xiexuliunian.github.io/2019/02/27/faster-rcnn重读记录/</id>
    <published>2019-02-27T21:03:52.000Z</published>
    <updated>2019-03-01T14:31:02.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="faster-rcnn重读记录笔记"><a href="#faster-rcnn重读记录笔记" class="headerlink" title="faster rcnn重读记录笔记"></a><center>faster rcnn重读记录笔记</center></h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&emsp;&emsp;年纪大了，之前看的好多文章，都忘得差不多了。深刻的明白了好记性不如烂笔头，现在看文章，准备记录下来，已备后来查阅。</p><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0 Abstract"></a>0 Abstract</h2><p>&emsp;&emsp;现在最先进的目标检测网络需要依赖<code>区域提出算法</code>假定目标的位置。SPPNET和FAST_RCNN已经缩短了检测网络的运行时间，暴露出区域提出计算的瓶颈。本文提出<code>区域提出网络(Region Proposal Network)</code>和检测网络共享全图像的卷积特征，因此做到几乎零消耗的区域提出效果。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>&emsp;&emsp;<code>SS(selective search)</code>是总多流行的区域提出方法之一，然而跟高效的检测网络相比落后一个数量级，在CPU的处理一张图片需要2秒。<code>EdgeBoxes</code>每张图片需要花费0.2秒，然而区域提出这一步花费的时间仍然跟检测网络一致。</p><p>&emsp;&emsp;采用GPU加速实现的区域提出方法是工程上有效的解决方案，但是这种重新实现忽略了下游的检测网络，错过了共享计算的重要机会。</p><p>&emsp;&emsp;我们发现在基于区域的检测器中用到的卷积特征也可以被用来生成区域建议网络。在这些卷积特征顶层，我们组建RPN通过添加一些额外的卷积层同时回归边界框和目标的概率在每个常见的单元的位置。</p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h2><p>&emsp;&emsp;广泛使用的目标提出方法包括基于超像素分组的方法(如SS,CPMC,MCG)和基于滑动窗口的方法(如EdgeBoxes)。目标提出方法在检测中充当一个独立的外部模块。</p><p>&emsp;&emsp;RCNN方法端到端的训练CNNs来对产生的区域进行判断是否包含物体或是背景。RCNN主要充当一个分类器，它不预测物体的边界框(除了refining边界框回归)。它的准确率取决于区域建议模块的表现。</p><h2 id="3-Faster-R-CNN"><a href="#3-Faster-R-CNN" class="headerlink" title="3 Faster R_CNN"></a>3 Faster R_CNN</h2><p>&emsp;&emsp;我们的检测系统，叫做Faster RCNN,由两部分组成。第一部分是用于区域建议的深度全卷积神经网络，第二部分是Fast RCNN检测器，它使用第一部分生成的建议区域。整个系统是一个简单、统一的目标检测网络。用最近在神经网络中很流行的术语注意力机制，RPN模块告诉Fast RCNN望哪里去看。</p><h3 id="3-1-RPN网络"><a href="#3-1-RPN网络" class="headerlink" title="3.1 RPN网络"></a>3.1 RPN网络</h3><p>&emsp;&emsp;RPN以一副任意尺度的图片作为输入，输出一系列矩形的目标建议框，每一个都有一个目标的置信度。<br>&emsp;&emsp;为了生成区域建议框，我们在共享的卷积层输出的卷积特征上滑动一个小的卷积网络。这个小的卷积网络采用一个nxn的空间窗作为卷积特征图的输入。每一个滑动窗口映射到一个低维的特征。这个特征送给两个兄弟全连接层中——一个框回归层(reg)，一个框分类层(cls)。在本文中我们使用n=3，这个迷你的网络在某个位置上的图示如下图。注意因为迷你的网络是一种滑动窗口的操作，全连接层共享了所有的空间信息。这种分格很自然的采用nxn的卷积层后面跟两个1x1的兄弟卷积层来实现(分别为了回归和分类)。</p><div style="width: 90%; margin: auto"><br><center><img src="/2019/02/27/faster-rcnn重读记录/1.jpg" title="图示"></center><br></div><h4 id="3-1-1-Anchors"><a href="#3-1-1-Anchors" class="headerlink" title="3.1.1 Anchors"></a>3.1.1 Anchors</h4><p>&emsp;&emsp;在每个滑动窗口的位置，我们同时预测多个区域建议框，他们每个位置的最大可能的建议框数目记为<em>k</em>。那么回归层就有4<em>k</em>个输出表征了<em>k</em>个框的坐标，分类层就输出2<em>k</em>个分数分表代表了每个建议框是和不是一个目标的概率。<em>k</em>个建议框是参数为<em>k</em>的引用框，我们称为Anchors。anchor位于滑动窗口的中心，和长宽比和比例有关。默认情况下我们使用3种长宽比和3种比例，在每个滑动的位置产生9个anchors。对于尺度为WxH特征图来说，那总共就有<em>WHk</em>个anchors。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;faster-rcnn重读记录笔记&quot;&gt;&lt;a href=&quot;#faster-rcnn重读记录笔记&quot; class=&quot;headerlink&quot; title=&quot;faster rcnn重读记录笔记&quot;&gt;&lt;/a&gt;&lt;center&gt;faster rcnn重读记录笔记&lt;/center&gt;&lt;
      
    
    </summary>
    
      <category term="论文" scheme="http://xiexuliunian.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>NMS 非极大值抑制</title>
    <link href="http://xiexuliunian.github.io/2019/01/18/NMS-%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6/"/>
    <id>http://xiexuliunian.github.io/2019/01/18/NMS-非极大值抑制/</id>
    <published>2019-01-18T19:21:37.000Z</published>
    <updated>2019-03-01T14:31:02.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NMS-非极大值抑制"><a href="#NMS-非极大值抑制" class="headerlink" title="NMS 非极大值抑制"></a><center>NMS 非极大值抑制</center></h1><p>&emsp;&emsp;<code>非极大值抑制(NMS)</code>是目标检测、人脸检测中比较常用的一种去除重复目标框的算法，下面以人脸检测为例子，详细的对NMS算法进行分析。</p><p>&emsp;&emsp;首先来看一副没有经过极大值抑制的人脸检测的图片。</p><div style="width: 60%; margin: auto"><br><center><img src="/2019/01/18/NMS-非极大值抑制/111.png" title="[NMS前效果]"></center><br></div><br>&emsp;&emsp;可以看到人脸周围有一些重复、混杂的候选框，这是我们不想看到的。<br><br>&emsp;&emsp;一般由模型生成的候选框格式为<em>Mx5</em>的矩阵如上图的13个候选框，可以表示为如下的矩阵。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[[605.81859586 241.9870858  700.2810722  364.39490232   0.99813652]</span><br><span class="line"> [604.46993595 241.94542132 701.05659627 362.6476619    0.99952543]</span><br><span class="line"> [607.75556511 242.27479172 700.98139177 361.36630836   0.99824369]</span><br><span class="line"> [607.31619582 235.84528071 703.34242228 364.37593491   0.99813581]</span><br><span class="line"> [391.33261696 232.13301024 503.14739725 368.47360138   0.99732131]</span><br><span class="line"> [389.78343755 231.74821711 504.23048349 369.45828512   0.99716467]</span><br><span class="line"> [149.77004275 265.61997575 257.41437337 382.3174709    0.99953663]</span><br><span class="line"> [390.23283872 230.75751062 504.22839069 372.18188326   0.99547029]</span><br><span class="line"> [391.34597505 232.12956198 504.59239189 368.02716969   0.99861956]</span><br><span class="line"> [391.51429539 230.70551069 507.19974793 375.07921828   0.99901474]</span><br><span class="line"> [389.82507351 230.74490997 502.93040028 373.79520297   0.99129468]</span><br><span class="line"> [151.20828396 263.95166993 255.72295459 382.8332618    0.99350882]</span><br><span class="line"> [390.00525969 227.63024712 504.61705256 378.54596627   0.99982077]]</span><br></pre></td></tr></table></figure><br><br>&emsp;&emsp;分表表示候选框的左上、右下坐标点及置信概率p,表示为：<code>[x1,y1,x2,y2,p]</code>，NMS是如何对上述候选框进行处理的呢?看代码吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">ef nms(boxes, overlap_threshold=<span class="number">0.5</span>, mode=<span class="string">'union'</span>):</span><br><span class="line">    x1 = boxes[:, <span class="number">0</span>]        <span class="comment">#矩形左上角的x坐标</span></span><br><span class="line">    y1 = boxes[:, <span class="number">1</span>]        <span class="comment">#矩形左上角的y坐标</span></span><br><span class="line">    x2 = boxes[:, <span class="number">2</span>]        <span class="comment">#矩形右下角的x坐标    </span></span><br><span class="line">    y2 = boxes[:, <span class="number">3</span>]        <span class="comment">#矩形右下角的y坐标</span></span><br><span class="line">    scores = boxes[:, <span class="number">4</span>]    <span class="comment">#矩形候选框的置信度</span></span><br><span class="line"></span><br><span class="line">    areas = (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>)   <span class="comment">#计算每个矩阵候选框的面积，+1是为了数值稳定性</span></span><br><span class="line">    order = scores.argsort()[::<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">#按置信度进行排序(从大到小)</span></span><br><span class="line">    <span class="comment">#返回值的索引[12  6  1  9  8  2  0  3  4  5  7 11 10]</span></span><br><span class="line"></span><br><span class="line">    keep = []       <span class="comment">#要保留的索引的列表</span></span><br><span class="line">    <span class="keyword">while</span> order.size &gt; <span class="number">0</span>:</span><br><span class="line">        i = order[<span class="number">0</span>]        <span class="comment">#取出置信度最大的索引</span></span><br><span class="line">        keep.append(i)      <span class="comment">#放在保留索引的列表中</span></span><br><span class="line">        xx1 = np.maximum(x1[i], x1[order[<span class="number">1</span>:]])  </span><br><span class="line">        yy1 = np.maximum(y1[i], y1[order[<span class="number">1</span>:]])</span><br><span class="line">        xx2 = np.minimum(x2[i], x2[order[<span class="number">1</span>:]])</span><br><span class="line">        yy2 = np.minimum(y2[i], y2[order[<span class="number">1</span>:]])</span><br><span class="line">        <span class="comment">#上述四句代码取选中的矩形框和其余的12个矩形框一一比对，取左上角坐标较大的和右下角坐标较小的。</span></span><br><span class="line">        <span class="comment">#如果两个矩形相交，则构成相交区域矩形的两个顶点</span></span><br><span class="line"></span><br><span class="line">        w = np.maximum(<span class="number">0.0</span>, xx2 - xx1 + <span class="number">1</span>)      <span class="comment">#相交时宽是正值，不想交的话宽为0</span></span><br><span class="line">        h = np.maximum(<span class="number">0.0</span>, yy2 - yy1 + <span class="number">1</span>)      <span class="comment">#相交时高是正值，不想交的话高为0</span></span><br><span class="line">        inter = w * h           <span class="comment">#计算交集的面积，不想交的话值为0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mode <span class="keyword">is</span> <span class="string">'min'</span>:</span><br><span class="line">            ovr = inter / np.minimum(areas[i], areas[order[<span class="number">1</span>:]])    <span class="comment">#交集占较小面积的比例</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ovr = inter / (areas[i] + areas[order[<span class="number">1</span>:]] - inter)     <span class="comment">#交集占并集的比例</span></span><br><span class="line">            <span class="comment">#[0.         0.         0.92467885 0.89049933 0.         0.</span></span><br><span class="line">            <span class="comment">#0.         0.8821858  0.90842802 0.93252505 0.         0.93301262]</span></span><br><span class="line"></span><br><span class="line">        inds = np.where(ovr &lt;= overlap_threshold)[<span class="number">0</span>]     <span class="comment">#获取比例小于阈值的ovr的索引[ 0  1  4  5  6 10]</span></span><br><span class="line">        order = order[inds + <span class="number">1</span>]                          <span class="comment">#order的索引为ovr的索引+1 order[1 2 5 6 7 11]</span></span><br><span class="line">        <span class="comment">#order=[ 6  1  2  0  3 11]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keep</span><br><span class="line">    <span class="comment"># keep=[12 6 1]</span></span><br><span class="line">    <span class="comment"># boxes=boxes[keep]</span></span><br><span class="line">    <span class="comment"># [[390.00525969 227.63024712 504.61705256 378.54596627   0.99982077]</span></span><br><span class="line">    <span class="comment"># [149.77004275 265.61997575 257.41437337 382.3174709    0.99953663]</span></span><br><span class="line">    <span class="comment"># [604.46993595 241.94542132 701.05659627 362.6476619    0.99952543]]</span></span><br></pre></td></tr></table></figure><br><br>&emsp;&emsp;经过NMS后的效果<br><div style="width: 60%; margin: auto"><br><center><img src="/2019/01/18/NMS-非极大值抑制/222.png" title="[NMS后效果]"></center><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NMS-非极大值抑制&quot;&gt;&lt;a href=&quot;#NMS-非极大值抑制&quot; class=&quot;headerlink&quot; title=&quot;NMS 非极大值抑制&quot;&gt;&lt;/a&gt;&lt;center&gt;NMS 非极大值抑制&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;非极大
      
    
    </summary>
    
      <category term="深度学习" scheme="http://xiexuliunian.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>计算数据集的mean和std</title>
    <link href="http://xiexuliunian.github.io/2019/01/16/%E8%AE%A1%E7%AE%97%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84mean%E5%92%8Cstd/"/>
    <id>http://xiexuliunian.github.io/2019/01/16/计算数据集的mean和std/</id>
    <published>2019-01-16T20:38:33.000Z</published>
    <updated>2019-03-01T14:31:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算数据集的mean和std"><a href="#计算数据集的mean和std" class="headerlink" title="计算数据集的mean和std"></a><center>计算数据集的mean和std</center></h1><p>&emsp;&emsp;经常我们要对数据集进行<code>标准化操作</code>，需要减去均值<code>mean</code>，除以标准差<code>std</code>,那就需要先计算出整个数据集的均值和标准差。下列代码给出两种方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets <span class="keyword">as</span> dsets</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">print(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CIFAR-10数据集</span></span><br><span class="line">train_dataset = dsets.CIFAR10(</span><br><span class="line">    root=<span class="string">"./data/"</span>, train=<span class="keyword">True</span>, transform=transforms.ToTensor(), download=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mean_and_std</span><span class="params">(dataset)</span>:</span></span><br><span class="line">    <span class="string">'''Compute the mean and std value of dataset.'''</span></span><br><span class="line">    dataloader = torch.utils.data.DataLoader(dataset, batch_size=<span class="number">1</span>, shuffle=<span class="keyword">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line">    mean = torch.zeros(<span class="number">3</span>)</span><br><span class="line">    std = torch.zeros(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'==&gt; Computing mean and std..'</span>)</span><br><span class="line">    <span class="keyword">for</span> inputs, targets <span class="keyword">in</span> dataloader:</span><br><span class="line">        <span class="comment"># 3通道</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            mean[i] += inputs[:, i, :, :].mean()</span><br><span class="line">            std[i] += inputs[:, i, :, :].std()</span><br><span class="line">    mean.div_(len(dataset))</span><br><span class="line">    std.div_(len(dataset))</span><br><span class="line">    <span class="keyword">return</span> mean, std</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#第一种方法</span></span><br><span class="line">    mean, std = get_mean_and_std(train_dataset);</span><br><span class="line">    print(mean, std, sep=<span class="string">'\n'</span>)</span><br><span class="line">    print(train_dataset.train_data.shape)</span><br><span class="line">    <span class="comment">#第二种方法</span></span><br><span class="line">    print(<span class="string">"data mean: %s"</span> % (np.mean(train_dataset.train_data, axis=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)) / <span class="number">255</span>))</span><br><span class="line">    print(<span class="string">"data std: %s"</span> % (np.std(train_dataset.train_data, axis=(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)) / <span class="number">255</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># cuda:0</span></span><br><span class="line"><span class="comment"># Files already downloaded and verified</span></span><br><span class="line"><span class="comment"># ==&gt; Computing mean and std..</span></span><br><span class="line"><span class="comment"># tensor([0.4914, 0.4822, 0.4465])</span></span><br><span class="line"><span class="comment"># tensor([0.2023, 0.1994, 0.2010])</span></span><br><span class="line"><span class="comment"># (50000, 32, 32, 3)</span></span><br><span class="line"><span class="comment"># data mean: [0.49139968 0.48215841 0.44653091]</span></span><br><span class="line"><span class="comment"># data std: [0.24703223 0.24348513 0.26158784]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算数据集的mean和std&quot;&gt;&lt;a href=&quot;#计算数据集的mean和std&quot; class=&quot;headerlink&quot; title=&quot;计算数据集的mean和std&quot;&gt;&lt;/a&gt;&lt;center&gt;计算数据集的mean和std&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&amp;emsp
      
    
    </summary>
    
      <category term="深度学习" scheme="http://xiexuliunian.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>pytorch和gluon的不同</title>
    <link href="http://xiexuliunian.github.io/2019/01/06/pytorch%E5%92%8Cgluon%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
    <id>http://xiexuliunian.github.io/2019/01/06/pytorch和gluon的不同/</id>
    <published>2019-01-06T09:58:44.000Z</published>
    <updated>2019-03-01T14:31:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pytorch和gluon的不同"><a href="#pytorch和gluon的不同" class="headerlink" title="pytorch和gluon的不同"></a><center>pytorch和gluon的不同</center></h1><p>&emsp;&emsp;由于经常使用pytorch和gluon发现他们有很多相同之处，同时也在混用他们，但是他们的不同之处经常搞得自己很混乱，因此在本篇博客里面，对他们的不同进行区分，以帮助自己理清思路。</p><h2 id="1-数据操作"><a href="#1-数据操作" class="headerlink" title="1. 数据操作"></a>1. 数据操作</h2><p>&emsp;&emsp;提到数据操作，在python里面最常用的是numpy数值计算库，但是该库不能支持gpu下运行，因此在大规模的张量情况下，两个深度学习计算库都有自己的核心数据操作库。在gluon里面是<code>NDArray(nd是其缩写形式)</code>,在pytorch里面是<code>tensor</code>。</p><p>&emsp;&emsp;<code>gluon</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.arange(<span class="number">12</span>)</span><br><span class="line">x=nd.arange(<span class="number">12</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.shape,x.size)</span><br><span class="line"></span><br><span class="line"><span class="comment">#[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10. 11.]</span></span><br><span class="line"><span class="comment">#&lt;NDArray 12 @cpu(0)&gt;</span></span><br><span class="line"><span class="comment">#(12,) 12</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>pytorch</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.arange(<span class="number">12</span>)</span><br><span class="line">b=torch.from_numpy(a)    <span class="comment">#从numpy建立tensor</span></span><br><span class="line">x=torch.arange(<span class="number">12</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.shape,x.size())</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span></span><br><span class="line"><span class="comment">#torch.Size([12]) torch.Size([12])</span></span><br><span class="line"><span class="comment">#tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11], dtype=torch.int32)</span></span><br></pre></td></tr></table></figure></p><h2 id="2-自动求导"><a href="#2-自动求导" class="headerlink" title="2.自动求导"></a>2.自动求导</h2><p>&emsp;&emsp;在gluon中对一个变量求导要先调用<code>attach_grad</code>函数来申请存储梯度所需要的内存。为了减少计算和内存开销，默认条件下 MXNet 不会记录用于求梯度的计算。我们需要调用record函数来要求 MXNet 记录与求梯度有关的计算。</p><p>&emsp;&emsp;<code>gluon</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd,nd</span><br><span class="line">x=nd.arange(<span class="number">1</span>,<span class="number">13</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(x)</span><br><span class="line">x.attach_grad()</span><br><span class="line"><span class="comment">#mxnet中默认关闭梯度，在此打开</span></span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    y=x**<span class="number">2</span>+<span class="number">4</span>*x</span><br><span class="line">    z=<span class="number">2</span>*y+<span class="number">3</span></span><br><span class="line">print(z)</span><br><span class="line">z.backward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># z是一个标量。接下来我们可以通过调用backward函数自动求梯度。需要注意的是，如果z不是一个标量，MXNet将默认先对z中元素求和得到新的变量，再求该变量有关x的梯度。</span></span><br><span class="line">print(x.grad)</span><br><span class="line"><span class="comment"># [[ 1.  2.  3.  4.]</span></span><br><span class="line"><span class="comment">#  [ 5.  6.  7.  8.]</span></span><br><span class="line"><span class="comment">#  [ 9. 10. 11. 12.]]</span></span><br><span class="line"><span class="comment"># &lt;NDArray 3x4 @cpu(0)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[ 13.  27.  45.  67.]</span></span><br><span class="line"><span class="comment">#  [ 93. 123. 157. 195.]</span></span><br><span class="line"><span class="comment">#  [237. 283. 333. 387.]]</span></span><br><span class="line"><span class="comment"># &lt;NDArray 3x4 @cpu(0)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[12. 16. 20. 24.]</span></span><br><span class="line"><span class="comment">#  [28. 32. 36. 40.]</span></span><br><span class="line"><span class="comment">#  [44. 48. 52. 56.]]</span></span><br><span class="line"><span class="comment"># &lt;NDArray 3x4 @cpu(0)&gt;</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在pytorch中对于tensor要求导，要为其附加一个<code>requires_grad</code>的属性。</p><p>&emsp;&emsp;<code>pytorch</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#指示x需要梯度</span></span><br><span class="line">x=torch.tensor(np.arange(<span class="number">1</span>,<span class="number">13</span>).reshape(<span class="number">3</span>,<span class="number">4</span>),dtype=torch.float32,requires_grad=<span class="keyword">True</span>)</span><br><span class="line">print(x)</span><br><span class="line">y=x**<span class="number">2</span>+<span class="number">4</span>*x</span><br><span class="line">z=<span class="number">2</span>*y+<span class="number">3</span></span><br><span class="line">print(z)</span><br><span class="line">z.sum().backward() <span class="comment">#先计算出标量和</span></span><br><span class="line">print(x.grad)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor([[ 1.,  2.,  3.,  4.],</span></span><br><span class="line"><span class="comment">#         [ 5.,  6.,  7.,  8.],</span></span><br><span class="line"><span class="comment">#         [ 9., 10., 11., 12.]], requires_grad=True)</span></span><br><span class="line"><span class="comment"># tensor([[ 13.,  27.,  45.,  67.],</span></span><br><span class="line"><span class="comment">#         [ 93., 123., 157., 195.],</span></span><br><span class="line"><span class="comment">#         [237., 283., 333., 387.]], grad_fn=&lt;AddBackward0&gt;)</span></span><br><span class="line"><span class="comment"># tensor([[12., 16., 20., 24.],</span></span><br><span class="line"><span class="comment">#         [28., 32., 36., 40.],</span></span><br><span class="line"><span class="comment">#         [44., 48., 52., 56.]])</span></span><br></pre></td></tr></table></figure></p><h2 id="3-计算设备"><a href="#3-计算设备" class="headerlink" title="3.计算设备"></a>3.计算设备</h2><p>&emsp;&emsp;实际操作中我们的很多操作都要在GPU中进行，那gluon和pytorch又是如何操作的呢？</p><p>&emsp;&emsp;<code>gluon</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=nd.arange(<span class="number">1</span>,<span class="number">13</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))    <span class="comment">#reshape(3,4)=reshape((3,4))</span></span><br><span class="line">b=a.as_in_context(mx.gpu())</span><br><span class="line">c=nd.array(np.arange(<span class="number">1</span>,<span class="number">13</span>).reshape(<span class="number">3</span>,<span class="number">4</span>),ctx=mx.gpu())</span><br><span class="line">d=nd.arange(<span class="number">1</span>,<span class="number">13</span>,ctx=mx.gpu()).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(a,b,c,d,sep=<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [[ 1.  2.  3.  4.]</span></span><br><span class="line"><span class="comment">#  [ 5.  6.  7.  8.]</span></span><br><span class="line"><span class="comment">#  [ 9. 10. 11. 12.]]</span></span><br><span class="line"><span class="comment"># &lt;NDArray 3x4 @cpu(0)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[ 1.  2.  3.  4.]</span></span><br><span class="line"><span class="comment">#  [ 5.  6.  7.  8.]</span></span><br><span class="line"><span class="comment">#  [ 9. 10. 11. 12.]]</span></span><br><span class="line"><span class="comment"># &lt;NDArray 3x4 @gpu(0)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[ 1.  2.  3.  4.]</span></span><br><span class="line"><span class="comment">#  [ 5.  6.  7.  8.]</span></span><br><span class="line"><span class="comment">#  [ 9. 10. 11. 12.]]</span></span><br><span class="line"><span class="comment"># &lt;NDArray 3x4 @gpu(0)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[ 1.  2.  3.  4.]</span></span><br><span class="line"><span class="comment">#  [ 5.  6.  7.  8.]</span></span><br><span class="line"><span class="comment">#  [ 9. 10. 11. 12.]]</span></span><br><span class="line"><span class="comment"># &lt;NDArray 3x4 @gpu(0)&gt;</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>pytorch</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=torch.tensor(np.arange(<span class="number">1</span>,<span class="number">13</span>).reshape(<span class="number">3</span>,<span class="number">4</span>),device=torch.device(<span class="string">'cuda'</span>))</span><br><span class="line">b=torch.tensor(np.arange(<span class="number">1</span>,<span class="number">13</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)).cuda()</span><br><span class="line">c=torch.arange(<span class="number">1</span>,<span class="number">13</span>,device=torch.device(<span class="string">'cuda'</span>)).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">d=torch.arange(<span class="number">1</span>,<span class="number">13</span>).cuda().reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">e=torch.arange(<span class="number">1</span>,<span class="number">13</span>).reshape(<span class="number">3</span>,<span class="number">4</span>).cuda()</span><br><span class="line">print(a,b,c,d,e,sep=<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor([[ 1,  2,  3,  4],</span></span><br><span class="line"><span class="comment">#         [ 5,  6,  7,  8],</span></span><br><span class="line"><span class="comment">#         [ 9, 10, 11, 12]], device='cuda:0', dtype=torch.int32)</span></span><br><span class="line"><span class="comment"># tensor([[ 1,  2,  3,  4],</span></span><br><span class="line"><span class="comment">#         [ 5,  6,  7,  8],</span></span><br><span class="line"><span class="comment">#         [ 9, 10, 11, 12]], device='cuda:0', dtype=torch.int32)</span></span><br><span class="line"><span class="comment"># tensor([[ 1,  2,  3,  4],</span></span><br><span class="line"><span class="comment">#         [ 5,  6,  7,  8],</span></span><br><span class="line"><span class="comment">#         [ 9, 10, 11, 12]], device='cuda:0')</span></span><br><span class="line"><span class="comment"># tensor([[ 1,  2,  3,  4],</span></span><br><span class="line"><span class="comment">#         [ 5,  6,  7,  8],</span></span><br><span class="line"><span class="comment">#         [ 9, 10, 11, 12]], device='cuda:0')</span></span><br><span class="line"><span class="comment"># tensor([[ 1,  2,  3,  4],</span></span><br><span class="line"><span class="comment">#         [ 5,  6,  7,  8],</span></span><br><span class="line"><span class="comment">#         [ 9, 10, 11, 12]], device='cuda:0')</span></span><br></pre></td></tr></table></figure></p><h2 id="4-模型构造"><a href="#4-模型构造" class="headerlink" title="4.模型构造"></a>4.模型构造</h2><p>&emsp;&emsp;以下都以<code>Alexnet</code>网络的构造为例，来说明两个框架的不同,在gluon中如下。</p><p>&emsp;&emsp;<code>gluon</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_gpu</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""If GPU is available, return mx.gpu(0); else return mx.cpu()"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ctx = mx.gpu()</span><br><span class="line">        _ = nd.zeros((<span class="number">1</span>,), ctx=ctx)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        ctx = mx.cpu()</span><br><span class="line">    <span class="keyword">return</span> ctx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ctx = try_gpu()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlexNet</span><span class="params">(nn.Block)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, classes=<span class="number">1000</span>, verbose=False, **kwargs)</span>:</span></span><br><span class="line">        super(AlexNet, self).__init__(**kwargs)</span><br><span class="line">        self.verbose = verbose</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            self.features = nn.Sequential(prefix=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">with</span> self.features.name_scope():</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">64</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>,</span><br><span class="line">                                            padding=<span class="number">2</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>))</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">192</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>,</span><br><span class="line">                                            activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>))</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>,</span><br><span class="line">                                            activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>,</span><br><span class="line">                                            activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>,</span><br><span class="line">                                            activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>))</span><br><span class="line">                <span class="comment"># Flatten层负责将(N,C,H,W)维度变为(N,C*H*W)维度</span></span><br><span class="line">                self.features.add(nn.Flatten())</span><br><span class="line">                self.features.add(nn.Dense(<span class="number">4096</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">                self.features.add(nn.Dense(<span class="number">4096</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">            self.output = nn.Dense(classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(self.features):</span><br><span class="line">            x = b(x)</span><br><span class="line">            <span class="keyword">if</span> self.verbose:</span><br><span class="line">                print(<span class="string">"features[%d] 输出维度: %s"</span> % (i + <span class="number">1</span>, x.shape))</span><br><span class="line">        x = self.output(x)</span><br><span class="line">        <span class="keyword">if</span> self.verbose:</span><br><span class="line">            print(<span class="string">"output 输出维度: %s"</span> % (x.shape,))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span><span class="params">(ctx, verbose=False)</span>:</span></span><br><span class="line">    classes = <span class="number">1000</span></span><br><span class="line">    net = AlexNet(classes, verbose=verbose)</span><br><span class="line">    <span class="comment"># 定义的网络需要初始化设备和参数</span></span><br><span class="line">    <span class="comment"># 相比于pytorch，gluon不需要指定输入的通道数，就是由于先对网络进行了初始化，</span></span><br><span class="line">    <span class="comment"># 可以推断出来输入的通道数量</span></span><br><span class="line">    net.initialize(ctx=ctx, init=init.Xavier())</span><br><span class="line">    <span class="comment"># net.initialize()</span></span><br><span class="line">    <span class="comment"># 默认的初始化方法是把所有权重初始化成在[-0.07, 0.07]之间均匀分布的随机数</span></span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    x = nd.random.uniform(shape=(<span class="number">32</span>, <span class="number">3</span>, <span class="number">227</span>, <span class="number">227</span>), ctx=ctx)</span><br><span class="line">    net = get_net(ctx, verbose=<span class="keyword">True</span>)</span><br><span class="line">    print(net)</span><br><span class="line">    y = net(x)</span><br><span class="line">    print(<span class="string">"输出y的维度: %s"</span> % (y.shape,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># AlexNet(</span></span><br><span class="line"><span class="comment">#   (features): Sequential(</span></span><br><span class="line"><span class="comment">#     (0): Conv2D(None -&gt; 64, kernel_size=(11, 11), stride=(4, 4), padding=(2, 2))</span></span><br><span class="line"><span class="comment">#     (1): MaxPool2D(size=(3, 3), stride=(2, 2), padding=(0, 0), ceil_mode=False)</span></span><br><span class="line"><span class="comment">#     (2): Conv2D(None -&gt; 192, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))</span></span><br><span class="line"><span class="comment">#     (3): MaxPool2D(size=(3, 3), stride=(2, 2), padding=(0, 0), ceil_mode=False)</span></span><br><span class="line"><span class="comment">#     (4): Conv2D(None -&gt; 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span></span><br><span class="line"><span class="comment">#     (5): Conv2D(None -&gt; 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span></span><br><span class="line"><span class="comment">#     (6): Conv2D(None -&gt; 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span></span><br><span class="line"><span class="comment">#     (7): MaxPool2D(size=(3, 3), stride=(2, 2), padding=(0, 0), ceil_mode=False)</span></span><br><span class="line"><span class="comment">#     (8): Flatten</span></span><br><span class="line"><span class="comment">#     (9): Dense(None -&gt; 4096, Activation(relu))</span></span><br><span class="line"><span class="comment">#     (10): Dropout(p = 0.5, axes=())</span></span><br><span class="line"><span class="comment">#     (11): Dense(None -&gt; 4096, Activation(relu))</span></span><br><span class="line"><span class="comment">#     (12): Dropout(p = 0.5, axes=())</span></span><br><span class="line"><span class="comment">#   )</span></span><br><span class="line"><span class="comment">#   (output): Dense(None -&gt; 1000, linear)</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"><span class="comment"># features[1] 输出维度: (32, 64, 56, 56)</span></span><br><span class="line"><span class="comment"># features[2] 输出维度: (32, 64, 27, 27)</span></span><br><span class="line"><span class="comment"># features[3] 输出维度: (32, 192, 27, 27)</span></span><br><span class="line"><span class="comment"># features[4] 输出维度: (32, 192, 13, 13)</span></span><br><span class="line"><span class="comment"># features[5] 输出维度: (32, 384, 13, 13)</span></span><br><span class="line"><span class="comment"># features[6] 输出维度: (32, 256, 13, 13)</span></span><br><span class="line"><span class="comment"># features[7] 输出维度: (32, 256, 13, 13)</span></span><br><span class="line"><span class="comment"># features[8] 输出维度: (32, 256, 6, 6)</span></span><br><span class="line"><span class="comment"># features[9] 输出维度: (32, 9216)</span></span><br><span class="line"><span class="comment"># features[10] 输出维度: (32, 4096)</span></span><br><span class="line"><span class="comment"># features[11] 输出维度: (32, 4096)</span></span><br><span class="line"><span class="comment"># features[12] 输出维度: (32, 4096)</span></span><br><span class="line"><span class="comment"># features[13] 输出维度: (32, 4096)</span></span><br><span class="line"><span class="comment"># output 输出维度: (32, 1000)</span></span><br><span class="line"><span class="comment"># 输出y的维度: (32, 1000)</span></span><br></pre></td></tr></table></figure></p><ul><li>命令式编程：可以拿到所有中间变量值。(NDArray方式)</li><li>符号式编程：更加高效而且更容易移植。(Symbol方式)</li></ul><p>&emsp;&emsp;通过使用 HybridBlock 或者 HybridSequential 来构建神经网络。默认他们跟 Block 和 Sequential 一样使用命令式执行。当我们调用<code>.hybridize()</code>后，系统会转换成符号式来执行。事实上，所有 Gluon 里定义的层全是 HybridBlock，这个意味着大部分的神经网络都可以享受符号式执行的优势。而如果使用gluon中的混合模式，要做相应的修改。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"><span class="keyword">import</span> mxnet <span class="keyword">as</span> mx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_gpu</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""If GPU is available, return mx.gpu(0); else return mx.cpu()"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ctx = mx.gpu()</span><br><span class="line">        _ = nd.zeros((<span class="number">1</span>,), ctx=ctx)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        ctx = mx.cpu()</span><br><span class="line">    <span class="keyword">return</span> ctx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ctx = try_gpu()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用HybridBlock</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlexNet</span><span class="params">(nn.HybridBlock)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, classes=<span class="number">1000</span>, verbose=False, **kwargs)</span>:</span></span><br><span class="line">        super(AlexNet, self).__init__(**kwargs)</span><br><span class="line">        self.verbose = verbose</span><br><span class="line">        <span class="keyword">with</span> self.name_scope():</span><br><span class="line">            <span class="comment"># 使用HybridSequential</span></span><br><span class="line">            self.features = nn.HybridSequential(prefix=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">with</span> self.features.name_scope():</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">64</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>,</span><br><span class="line">                                            padding=<span class="number">2</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>))</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">192</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>,</span><br><span class="line">                                            activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>))</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>,</span><br><span class="line">                                            activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>,</span><br><span class="line">                                            activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.Conv2D(<span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>,</span><br><span class="line">                                            activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.MaxPool2D(pool_size=<span class="number">3</span>, strides=<span class="number">2</span>))</span><br><span class="line">                <span class="comment"># Flatten层负责将(N,C,H,W)维度变为(N,C*H*W)维度</span></span><br><span class="line">                self.features.add(nn.Flatten())</span><br><span class="line">                self.features.add(nn.Dense(<span class="number">4096</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">                self.features.add(nn.Dense(<span class="number">4096</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">                self.features.add(nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">            self.output = nn.Dense(classes)</span><br><span class="line">    <span class="comment"># 相比之前加了个参数F</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hybrid_forward</span><span class="params">(self, F, x)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(self.features):</span><br><span class="line">            x = b(x)</span><br><span class="line">            <span class="keyword">if</span> self.verbose:</span><br><span class="line">                print(<span class="string">"features[%d] 输出维度: %s"</span> % (i + <span class="number">1</span>, x.shape))</span><br><span class="line">        x = self.output(x)</span><br><span class="line">        <span class="keyword">if</span> self.verbose:</span><br><span class="line">            print(<span class="string">"output 输出维度: %s"</span> % (x.shape,))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span><span class="params">(ctx, verbose=False)</span>:</span></span><br><span class="line">    classes = <span class="number">1000</span></span><br><span class="line">    net = AlexNet(classes, verbose=verbose)</span><br><span class="line">    <span class="comment"># 定义的网络需要初始化设备和参数</span></span><br><span class="line">    <span class="comment"># 相比于pytorch，gluon不需要指定输入的通道数，就是由于先对网络进行了初始化，</span></span><br><span class="line">    <span class="comment"># 可以推断出来输入的通道数量</span></span><br><span class="line">    net.initialize(ctx=ctx, init=init.Xavier())</span><br><span class="line">    <span class="comment"># net.hybridize()  享受训练网络加速，但是采用symbol模式后，中间过程的shape就拿不到了</span></span><br><span class="line">    <span class="comment"># net.initialize()</span></span><br><span class="line">    <span class="comment"># 默认的初始化方法是把所有权重初始化成在[-0.07, 0.07]之间均匀分布的随机数</span></span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    x = nd.random.uniform(shape=(<span class="number">32</span>, <span class="number">3</span>, <span class="number">227</span>, <span class="number">227</span>), ctx=ctx)</span><br><span class="line">    net = get_net(ctx, verbose=<span class="keyword">True</span>)</span><br><span class="line">    print(net)</span><br><span class="line">    y = net(x)</span><br><span class="line">    print(<span class="string">"输出y的维度: %s"</span> % (y.shape,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># AlexNet(</span></span><br><span class="line"><span class="comment">#   (features): HybridSequential(</span></span><br><span class="line"><span class="comment">#     (0): Conv2D(None -&gt; 64, kernel_size=(11, 11), stride=(4, 4), padding=(2, 2))</span></span><br><span class="line"><span class="comment">#     (1): MaxPool2D(size=(3, 3), stride=(2, 2), padding=(0, 0), ceil_mode=False)</span></span><br><span class="line"><span class="comment">#     (2): Conv2D(None -&gt; 192, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))</span></span><br><span class="line"><span class="comment">#     (3): MaxPool2D(size=(3, 3), stride=(2, 2), padding=(0, 0), ceil_mode=False)</span></span><br><span class="line"><span class="comment">#     (4): Conv2D(None -&gt; 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span></span><br><span class="line"><span class="comment">#     (5): Conv2D(None -&gt; 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span></span><br><span class="line"><span class="comment">#     (6): Conv2D(None -&gt; 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span></span><br><span class="line"><span class="comment">#     (7): MaxPool2D(size=(3, 3), stride=(2, 2), padding=(0, 0), ceil_mode=False)</span></span><br><span class="line"><span class="comment">#     (8): Flatten</span></span><br><span class="line"><span class="comment">#     (9): Dense(None -&gt; 4096, Activation(relu))</span></span><br><span class="line"><span class="comment">#     (10): Dropout(p = 0.5, axes=())</span></span><br><span class="line"><span class="comment">#     (11): Dense(None -&gt; 4096, Activation(relu))</span></span><br><span class="line"><span class="comment">#     (12): Dropout(p = 0.5, axes=())</span></span><br><span class="line"><span class="comment">#   )</span></span><br><span class="line"><span class="comment">#   (output): Dense(None -&gt; 1000, linear)</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"><span class="comment"># features[1] 输出维度: (32, 64, 56, 56)</span></span><br><span class="line"><span class="comment"># features[2] 输出维度: (32, 64, 27, 27)</span></span><br><span class="line"><span class="comment"># features[3] 输出维度: (32, 192, 27, 27)</span></span><br><span class="line"><span class="comment"># features[4] 输出维度: (32, 192, 13, 13)</span></span><br><span class="line"><span class="comment"># features[5] 输出维度: (32, 384, 13, 13)</span></span><br><span class="line"><span class="comment"># features[6] 输出维度: (32, 256, 13, 13)</span></span><br><span class="line"><span class="comment"># features[7] 输出维度: (32, 256, 13, 13)</span></span><br><span class="line"><span class="comment"># features[8] 输出维度: (32, 256, 6, 6)</span></span><br><span class="line"><span class="comment"># features[9] 输出维度: (32, 9216)</span></span><br><span class="line"><span class="comment"># features[10] 输出维度: (32, 4096)</span></span><br><span class="line"><span class="comment"># features[11] 输出维度: (32, 4096)</span></span><br><span class="line"><span class="comment"># features[12] 输出维度: (32, 4096)</span></span><br><span class="line"><span class="comment"># features[13] 输出维度: (32, 4096)</span></span><br><span class="line"><span class="comment"># output 输出维度: (32, 1000)</span></span><br><span class="line"><span class="comment"># 输出y的维度: (32, 1000)</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>pytorch</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlexNet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes=<span class="number">1000</span>,verbose=False)</span>:</span></span><br><span class="line">        super(AlexNet, self).__init__()</span><br><span class="line">        self.verbose=verbose</span><br><span class="line">        self.features = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=<span class="number">11</span>, stride=<span class="number">4</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">192</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">192</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">384</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),</span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">        )</span><br><span class="line">        self.classifier = nn.Sequential(</span><br><span class="line">            nn.Dropout(),</span><br><span class="line">            nn.Linear(<span class="number">256</span> * <span class="number">6</span> * <span class="number">6</span>, <span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),</span><br><span class="line">            nn.Dropout(),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="keyword">True</span>),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>, num_classes),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(self.features):</span><br><span class="line">            x = b(x)</span><br><span class="line">            <span class="keyword">if</span> self.verbose:</span><br><span class="line">                print(<span class="string">"features[%d] 输出维度: %s"</span> % (i + <span class="number">1</span>, x.shape))</span><br><span class="line">        <span class="comment"># x = x.view(x.size(0), 256 * 6 * 6)</span></span><br><span class="line">        <span class="comment"># x = x.view(x.size(0), -1)</span></span><br><span class="line">        x = x.reshape(x.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> i,b <span class="keyword">in</span> enumerate(self.classifier):</span><br><span class="line">            x=b(x)</span><br><span class="line">            <span class="keyword">if</span> self.verbose:</span><br><span class="line">                print(<span class="string">"classifier[%d] 输出维度: %s"</span> % (i + <span class="number">1</span>, x.shape))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span><span class="params">(device,verbose=False)</span>:</span></span><br><span class="line">    classes=<span class="number">1000</span></span><br><span class="line">    net=AlexNet(classes,verbose=<span class="keyword">True</span>).to(device)</span><br><span class="line">    <span class="comment"># net = AlexNet(classes, verbose=True,device=device)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    x=torch.nn.init.uniform_(torch.Tensor(<span class="number">32</span>,<span class="number">3</span>,<span class="number">227</span>,<span class="number">227</span>)).to(device)</span><br><span class="line">    net=get_net(device,verbose=<span class="keyword">True</span>)</span><br><span class="line">    print(net)</span><br><span class="line">    y=net(x)</span><br><span class="line">    print(<span class="string">"输出y的维度: %s"</span> % (y.shape,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># AlexNet(</span></span><br><span class="line"><span class="comment">#   (features): Sequential(</span></span><br><span class="line"><span class="comment">#     (0): Conv2d(3, 64, kernel_size=(11, 11), stride=(4, 4), padding=(2, 2))</span></span><br><span class="line"><span class="comment">#     (1): ReLU(inplace)</span></span><br><span class="line"><span class="comment">#     (2): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="comment">#     (3): Conv2d(64, 192, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2))</span></span><br><span class="line"><span class="comment">#     (4): ReLU(inplace)</span></span><br><span class="line"><span class="comment">#     (5): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="comment">#     (6): Conv2d(192, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span></span><br><span class="line"><span class="comment">#     (7): ReLU(inplace)</span></span><br><span class="line"><span class="comment">#     (8): Conv2d(384, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span></span><br><span class="line"><span class="comment">#     (9): ReLU(inplace)</span></span><br><span class="line"><span class="comment">#     (10): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))</span></span><br><span class="line"><span class="comment">#     (11): ReLU(inplace)</span></span><br><span class="line"><span class="comment">#     (12): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="comment">#   )</span></span><br><span class="line"><span class="comment">#   (classifier): Sequential(</span></span><br><span class="line"><span class="comment">#     (0): Dropout(p=0.5)</span></span><br><span class="line"><span class="comment">#     (1): Linear(in_features=9216, out_features=4096, bias=True)</span></span><br><span class="line"><span class="comment">#     (2): ReLU(inplace)</span></span><br><span class="line"><span class="comment">#     (3): Dropout(p=0.5)</span></span><br><span class="line"><span class="comment">#     (4): Linear(in_features=4096, out_features=4096, bias=True)</span></span><br><span class="line"><span class="comment">#     (5): ReLU(inplace)</span></span><br><span class="line"><span class="comment">#     (6): Linear(in_features=4096, out_features=1000, bias=True)</span></span><br><span class="line"><span class="comment">#   )</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"><span class="comment"># features[1] 输出维度: torch.Size([32, 64, 56, 56])</span></span><br><span class="line"><span class="comment"># features[2] 输出维度: torch.Size([32, 64, 56, 56])</span></span><br><span class="line"><span class="comment"># features[3] 输出维度: torch.Size([32, 64, 27, 27])</span></span><br><span class="line"><span class="comment"># features[4] 输出维度: torch.Size([32, 192, 27, 27])</span></span><br><span class="line"><span class="comment"># features[5] 输出维度: torch.Size([32, 192, 27, 27])</span></span><br><span class="line"><span class="comment"># features[6] 输出维度: torch.Size([32, 192, 13, 13])</span></span><br><span class="line"><span class="comment"># features[7] 输出维度: torch.Size([32, 384, 13, 13])</span></span><br><span class="line"><span class="comment"># features[8] 输出维度: torch.Size([32, 384, 13, 13])</span></span><br><span class="line"><span class="comment"># features[9] 输出维度: torch.Size([32, 256, 13, 13])</span></span><br><span class="line"><span class="comment"># features[10] 输出维度: torch.Size([32, 256, 13, 13])</span></span><br><span class="line"><span class="comment"># features[11] 输出维度: torch.Size([32, 256, 13, 13])</span></span><br><span class="line"><span class="comment"># features[12] 输出维度: torch.Size([32, 256, 13, 13])</span></span><br><span class="line"><span class="comment"># features[13] 输出维度: torch.Size([32, 256, 6, 6])</span></span><br><span class="line"><span class="comment"># classifier[1] 输出维度: torch.Size([32, 9216])</span></span><br><span class="line"><span class="comment"># classifier[2] 输出维度: torch.Size([32, 4096])</span></span><br><span class="line"><span class="comment"># classifier[3] 输出维度: torch.Size([32, 4096])</span></span><br><span class="line"><span class="comment"># classifier[4] 输出维度: torch.Size([32, 4096])</span></span><br><span class="line"><span class="comment"># classifier[5] 输出维度: torch.Size([32, 4096])</span></span><br><span class="line"><span class="comment"># classifier[6] 输出维度: torch.Size([32, 4096])</span></span><br><span class="line"><span class="comment"># classifier[7] 输出维度: torch.Size([32, 1000])</span></span><br><span class="line"><span class="comment"># 输出y的维度: torch.Size([32, 1000])</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;从中可以看出gluon里面的激活函数是内嵌在每一层里面的，作为一个参数，而pytorch是作为一个层来看的。</p><h2 id="5-优化器"><a href="#5-优化器" class="headerlink" title="5.优化器"></a>5.优化器</h2><p>&emsp;&emsp;两种框架的优化器写法不一样。同样都是SGD优化器</p><p>&emsp;&emsp;<code>gluon</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trainer = gluon.Trainer(</span><br><span class="line">        net.collect_params(), <span class="string">'sgd'</span>, &#123;<span class="string">'learning_rate'</span>: lr, <span class="string">'momentum'</span>: <span class="number">0.9</span>, <span class="string">'wd'</span>: wd&#125;)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>pytorch</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer=torch.optim.SGD(net.parameters(),lr=lr,momentum=<span class="number">0.9</span>,weight_decay=wd)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pytorch和gluon的不同&quot;&gt;&lt;a href=&quot;#pytorch和gluon的不同&quot; class=&quot;headerlink&quot; title=&quot;pytorch和gluon的不同&quot;&gt;&lt;/a&gt;&lt;center&gt;pytorch和gluon的不同&lt;/center&gt;&lt;/h1&gt;
      
    
    </summary>
    
      <category term="深度学习" scheme="http://xiexuliunian.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>临江仙.彩云</title>
    <link href="http://xiexuliunian.github.io/2018/11/30/%E4%B8%B4%E6%B1%9F%E4%BB%99-%E5%BD%A9%E4%BA%91/"/>
    <id>http://xiexuliunian.github.io/2018/11/30/临江仙-彩云/</id>
    <published>2018-11-30T22:24:09.000Z</published>
    <updated>2019-03-01T14:31:02.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="临江仙-彩云"><a href="#临江仙-彩云" class="headerlink" title="临江仙.彩云"></a><center>临江仙.彩云</center></h2><h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><blockquote><font color="Violet" size="4px">&emsp;&emsp;天朗应是无昧，久病去又还来。斜晖又染映天红，秋来收蒲草，人伴彩云台。</font><font color="Violet" size="4px">&emsp;&emsp;若是相思无益，更行更远还猜。栀子花开百褶白，曾记年岁好，许我牡丹开。</font></blockquote><h2 id="—-1"><a href="#—-1" class="headerlink" title="—"></a>—</h2><blockquote><p>&emsp;&emsp;注:词写于十一回家，在楼顶与妹妹看落霞。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;临江仙-彩云&quot;&gt;&lt;a href=&quot;#临江仙-彩云&quot; class=&quot;headerlink&quot; title=&quot;临江仙.彩云&quot;&gt;&lt;/a&gt;&lt;center&gt;临江仙.彩云&lt;/center&gt;&lt;/h2&gt;&lt;h2 id=&quot;—&quot;&gt;&lt;a href=&quot;#—&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="词" scheme="http://xiexuliunian.github.io/categories/%E8%AF%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>月</title>
    <link href="http://xiexuliunian.github.io/2018/11/30/%E6%9C%88/"/>
    <id>http://xiexuliunian.github.io/2018/11/30/月/</id>
    <published>2018-11-30T21:49:58.000Z</published>
    <updated>2019-03-01T14:31:02.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="月"><a href="#月" class="headerlink" title="月"></a><center>月</center></h2><h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><center><font color="Violet" size="4px">月出濛濛雨，</font></center><br><center><font color="Violet" size="4px">皎皎入人心。</font></center><br><center><font color="Violet" size="4px">夜深添寒幕，</font></center><br><center><font color="Violet" size="4px">灯黄忆暖亲。</font></center><br><center><font color="Violet" size="4px">白头黄连翘，</font></center><br><center><font color="Violet" size="4px">半夏天南星。</font></center><br><center><font color="Violet" size="4px">遇上方知有，</font></center><br><center><font color="Violet" size="4px">留得颜照君。</font></center><h2 id="—-1"><a href="#—-1" class="headerlink" title="—"></a>—</h2><blockquote><p>&emsp;&emsp;注：此诗写于初冬细雨之后，晚上天色濛濛，正值满月来回于暮云之间，时有时无，那种皎洁，给人一种直入人心的感觉。此外，此诗写给<code>颜照君</code>。</p></blockquote><p>作于2018.11.21日</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;月&quot;&gt;&lt;a href=&quot;#月&quot; class=&quot;headerlink&quot; title=&quot;月&quot;&gt;&lt;/a&gt;&lt;center&gt;月&lt;/center&gt;&lt;/h2&gt;&lt;h2 id=&quot;—&quot;&gt;&lt;a href=&quot;#—&quot; class=&quot;headerlink&quot; title=&quot;—&quot;&gt;&lt;/a&gt;—&lt;/
      
    
    </summary>
    
      <category term="诗" scheme="http://xiexuliunian.github.io/categories/%E8%AF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>docker学习</title>
    <link href="http://xiexuliunian.github.io/2018/11/16/docker%E5%AD%A6%E4%B9%A0/"/>
    <id>http://xiexuliunian.github.io/2018/11/16/docker学习/</id>
    <published>2018-11-16T20:04:36.000Z</published>
    <updated>2019-03-01T14:31:02.296Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;现今容器化技术对于技术行业的改变是非常巨大的，特别是对于企业来说，因此学习掌握容器化技术的基础是非常必要的。</p><h2 id="1-docker安装"><a href="#1-docker安装" class="headerlink" title="1.docker安装"></a>1.docker安装</h2><p>&emsp;&emsp;本文使用manjaro(Archlinux)系linux系统，由于有pacman、yaour管理软件包的加持，加上manjaro的图形化前端pamac,如下图</p><div style="width: 80%; margin: auto"><br><center><img src="/2018/11/16/docker学习/1.png" title="说明"></center><br></div><p>&emsp;&emsp;安装docker，nvidia-docker只需要点安装即可，当然前提是你要有个好的网络，接下来会写一篇讲如何在linux下使用全局代理的博文，以备不时之需。</p><h3 id="建立docker用户组"><a href="#建立docker用户组" class="headerlink" title="建立docker用户组"></a>建立docker用户组</h3><p>&emsp;&emsp;默认情况下，<code>docker</code>命令会使用 <code>Unix socket</code>与 <code>Docker</code>引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 <code>Unix socket</code>。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 docker 的用户加入 <code>docker</code> 用户组。</p><p>建立<code>docker</code>组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure></p><p>将当前用户加入<code>docker</code>组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure></p><p>退出当前终端并重新登录，进行如下测试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure></p><p>正常情况下你会得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure></p><h2 id="2-遇到的第一个问题"><a href="#2-遇到的第一个问题" class="headerlink" title="2.遇到的第一个问题"></a>2.遇到的第一个问题</h2><p>但是你很有可能会得到：</p><blockquote><p>Cannot connect to the Docker daemon at unix:/var/run/docker.sock. Is the docker daemon running?</p></blockquote><p>&emsp;&emsp;这是肿么回事呢？<font color="Violet" size="3px">因为你只是安装了docker服务，但是没有启动呀!</font></p><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><p><code>sudo systemctl start docker</code>:  启动docker服务</p><p><code>sudo systemctl enable docker</code>: <strong>开机启动docker服务</strong></p><p>&emsp;&emsp;再运行之前的命令就没有什么问题了，当然前提是你有一个好的网络，那如果网络不好，怎么知道我有没有安装启动好服务呢？</p><p><code>docker info</code>命令可以显示出当前的docker环境的一些信息，若显示正常，那应该没什么问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ docker info           </span><br><span class="line">Containers: 3</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 3</span><br><span class="line">Images: 2</span><br><span class="line">Server Version: 18.09.0-ce</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: false</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: nvidia runc</span><br><span class="line">Default Runtime: nvidia</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9f2e07b1fc1342d1c48fe4d7bbb94cb6d1bf278b.m</span><br><span class="line">runc version: 4fc53a81fb7c994640722ac585fa9ca548971871-dirty</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.14.80-1-MANJARO</span><br><span class="line">Operating System: Manjaro Linux</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 8</span><br><span class="line">Total Memory: 15.6GiB</span><br><span class="line">Name: zxd</span><br><span class="line">ID: JEYJ:QQXD:VSQ3:RRDA:ETZN:BEON:QFLV:UWUY:YRYE:UTUE:7M5U:VM62</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): false</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Live Restore Enabled: false</span><br></pre></td></tr></table></figure></p><h2 id="3-镜像-容器-仓库"><a href="#3-镜像-容器-仓库" class="headerlink" title="3. 镜像 容器 仓库"></a>3. 镜像 容器 仓库</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>&emsp;&emsp;我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。</p><p>&emsp;&emsp; 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>&emsp;&emsp;镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>&emsp;&emsp;镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>&emsp;&emsp;容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>&emsp;&emsp;前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p><p>&emsp;&emsp;容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>&emsp;&emsp;按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>&emsp;&emsp;数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>&emsp;&emsp;镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p><p>&emsp;&emsp;一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>&emsp;&emsp;通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><p>&emsp;&emsp;以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，14.04, 16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。</p><p>&emsp;&emsp;仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h2 id="4-使用镜像"><a href="#4-使用镜像" class="headerlink" title="4. 使用镜像"></a>4. 使用镜像</h2><p>&emsp;&emsp;在之前的介绍中，我们知道镜像是 Docker 的三大组件之一。<br>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p><h3 id="4-1-获取镜像"><a href="#4-1-获取镜像" class="headerlink" title="4.1 获取镜像"></a>4.1 获取镜像</h3><p>&emsp;&emsp;之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>&emsp;&emsp;从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;具体的选项可以通过 docker pull –help 命令看到，这里我们说一下镜像名称的格式。</p><p>&emsp;&emsp;Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。</p><p>&emsp;&emsp;仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:16.04</span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line">18d680d61657: Pull complete </span><br><span class="line">0addb6fece63: Pull complete </span><br><span class="line">78e58219b215: Pull complete </span><br><span class="line">eb6959a66df2: Pull complete </span><br><span class="line">Digest: sha256:76702ec53c5e7771ba3f2c4f6152c3796c142af2b3cb1a02fce66c697db24f12</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;看一下现在都有哪些镜像了</p><p>&emsp;&emsp;<code>docker image ls</code>==<code>docker images</code>都是列出已存在的镜像的意思。</p><div style="width: 100%; margin: auto"><br><center><img src="/2018/11/16/docker学习/2.png" title="说明"></center><br></div><h3 id="4-2-运行镜像"><a href="#4-2-运行镜像" class="headerlink" title="4.2 运行镜像"></a>4.2 运行镜像</h3><p>&emsp;&emsp;直接从镜像运行需要使用<code>docker run</code></p><blockquote><p>docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li><li>&emsp;&emsp;<code>docker run -i -t --rm ubuntu:latest bash</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># zxd @ zxd in ~ [15:28:01] </span><br><span class="line">$ docker run -i -t --rm ubuntu:latest bash</span><br><span class="line">root@1a0399b42d27:/# cat /etc/os-release </span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;18.04.1 LTS (Bionic Beaver)&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 18.04.1 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;18.04&quot;</span><br><span class="line">HOME_URL=&quot;https://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>&emsp;&emsp;<code>docker run</code> 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li><li><code>ubuntu:latest</code>：这是指用 ubuntu:latest 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 8.04.1 LTS 系统。</li><li><code>--name</code> : 标注启动的容器的名字，不然会随机生成一个名字。</li></ul><p>&emsp;&emsp;最后我们通过 exit 退出了这个容器。</p><p>&emsp;&emsp;<font color="Violet" size="3px">这里注意一点，各种操作指令放在前面，后面放镜像名。</font></p><h3 id="4-3-查看运行的容器"><a href="#4-3-查看运行的容器" class="headerlink" title="4.3 查看运行的容器"></a>4.3 查看运行的容器</h3><p>&emsp;&emsp;使用<code>docker ps</code>来查看正在运行的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">5035e60c8e24        ubuntu:latest       &quot;/bin/bash&quot;         21 hours ago        Up 2 hours                              ubuntu</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用<code>docker ps -a</code>来查看所有启动过的容器，包括停止的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a </span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">5035e60c8e24        ubuntu:latest       &quot;/bin/bash&quot;         21 hours ago        Up 2 hours                                    ubuntu</span><br><span class="line">2242a78ae6f1        hello-world         &quot;/hello&quot;            22 hours ago        Exited (0) 22 hours ago                       eloquent_cohen</span><br></pre></td></tr></table></figure></p><h3 id="4-4-删除容器或镜像"><a href="#4-4-删除容器或镜像" class="headerlink" title="4.4 删除容器或镜像"></a>4.4 删除容器或镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm [容器ID或名字]      //删除容器</span><br><span class="line">docker rmi [镜像ID或名字]     //删除镜像</span><br></pre></td></tr></table></figure><h2 id="5-Dockerfile"><a href="#5-Dockerfile" class="headerlink" title="5. Dockerfile"></a>5. Dockerfile</h2><p>&emsp;&emsp;<code>Dockerfile</code> 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"><span class="keyword">RUN</span> apt-get update</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。</p><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>&emsp;&emsp;所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p><p>&emsp;&emsp;在 <a href="https://store.docker.com/" target="_blank" rel="noopener">Docker Store</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>&emsp;&emsp;如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>&emsp;&emsp;除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p>&emsp;&emsp;RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get update</span><br></pre></td></tr></table></figure></li><li><p>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]</p></li></ul><p>&emsp;&emsp;既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz"</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p><p>&emsp;&emsp;而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><code>上面的 Dockerfile 正确的写法应该是这样：</code><br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span> buildDeps='gcc libc6-dev make' \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; rm redis.tar.gz \</span><br><span class="line">    &amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>&emsp;&emsp;并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>&emsp;&emsp;此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>&emsp;&emsp;很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 <code>Dockerfile</code> 文件所在目录执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myubuntu .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM ubuntu:latest</span><br><span class="line"> ---&gt; ea4c82dcd15a</span><br><span class="line">Step 2/2 : RUN apt-get update</span><br><span class="line"> ---&gt; Running in 5f945d0d62fb</span><br><span class="line">Get:1 http://security.ubuntu.com/ubuntu bionic-security InRelease [83.2 kB]</span><br><span class="line">Get:2 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB]</span><br><span class="line">Get:3 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 Packages [1367 B]</span><br><span class="line">Get:4 http://security.ubuntu.com/ubuntu bionic-security/main amd64 Packages [262 kB]</span><br><span class="line">Get:5 http://archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]</span><br><span class="line">Get:6 http://archive.ubuntu.com/ubuntu bionic-backports InRelease [74.6 kB]</span><br><span class="line">Get:7 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [119 kB]</span><br><span class="line">Get:8 http://archive.ubuntu.com/ubuntu bionic/multiverse amd64 Packages [186 kB]</span><br><span class="line">Get:9 http://archive.ubuntu.com/ubuntu bionic/main amd64 Packages [1344 kB]</span><br><span class="line">Get:10 http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages [11.3 MB]</span><br><span class="line">Get:11 http://archive.ubuntu.com/ubuntu bionic/restricted amd64 Packages [13.5 kB]</span><br><span class="line">Get:12 http://archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages [730 kB]</span><br><span class="line">Get:13 http://archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 Packages [10.7 kB]</span><br><span class="line">Get:14 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages [567 kB]</span><br><span class="line">Get:15 http://archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages [6142 B]</span><br><span class="line">Get:16 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages [2975 B]</span><br><span class="line">Fetched 15.1 MB in 6s (2412 kB/s)</span><br><span class="line">Reading package lists...</span><br><span class="line">Removing intermediate container 5f945d0d62fb</span><br><span class="line"> ---&gt; f55da3abb808</span><br><span class="line">Successfully built f55da3abb808</span><br><span class="line">Successfully tagged myubuntu:latest</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 <code>5f945d0d62fb</code>，执行了所要求的命令，并最后提交了这一层 <code>f55da3abb808</code>，随后删除了所用到的这个容器 <code>5f945d0d62fb</code>。</p><p>这里我们使用了 docker build 命令进行镜像构建。其格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure></p><ul><li><code>-t</code> : 指明生成镜像名称</li></ul><p>&emsp;&emsp;如果注意，会看到 docker build 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？</p><p>&emsp;&emsp;首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>&emsp;&emsp;当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>&emsp;&emsp;这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>&emsp;&emsp;一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>&emsp;&emsp;那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p><p>&emsp;&emsp;这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。</p><p>&emsp;&emsp;当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p><h2 id="6-Dockerfile指令详解"><a href="#6-Dockerfile指令详解" class="headerlink" title="6. Dockerfile指令详解"></a>6. Dockerfile指令详解</h2><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>&emsp;&emsp;<code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code>的文件/目录复制到新的一层的镜像内的<code>&lt;目标路径&gt;</code>位置。比如：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span> package.json /usr/src/app/</span><br></pre></td></tr></table></figure></p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>&emsp;&emsp;<code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>&emsp;&emsp;在 <code>Docker</code> 官方的 <code>Dockerfile</code> 最佳实践文档 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>&emsp;&emsp;在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li>shell 格式：CMD &lt;命令&gt;</li><li>exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</li><li>参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</li></ul><p>&emsp;&emsp;之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。</p><p>&emsp;&emsp;如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"><span class="keyword">RUN</span> apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y curl \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD curl cip.cc     /等价于 CMD ["curl","-s","cip.cc"]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;最后的<code>CMD curl cip.cc</code>在实际的执行中会将其变为：</p><p>&emsp;&emsp;<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;curl cip.cc&quot; ]</code>,也就是说主进程实际上是 <code>sh</code>。那么当 <code>curl cip.cc</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t curl .     //构建新的镜像命名为curl</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker run --rm curl:latest          </span><br><span class="line">IP: 153.3.0.xx</span><br><span class="line">地址: 中国 xx  xx</span><br><span class="line">运营商: 联通</span><br><span class="line"></span><br><span class="line">数据二: 江苏省xx市 | 联通</span><br><span class="line"></span><br><span class="line">数据三: 中国江苏省xx市 | 联通</span><br><span class="line"></span><br><span class="line">URL: http://www.cip.cc/153.3.0.xx</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那如果我们想在后面加个参数<code>-i</code>,希望显示 HTTP 头信息，直接在<code>docker run</code>的后面加能行吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm curl:latest -i          </span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \&quot;-i\&quot;: executable file not found in $PATH&quot;: unknown.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;但是我们可以这样，在镜像后面敲出完整的指令，<font color="Violet" size="3px">因为跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。</font>因此这里的 <code>curl -s cip.cc -i</code> 替换了原来的 <code>CMD</code>，而原来的<code>-i</code>根本就不是合法的命令，所以自然找不到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm curl:latest curl -s cip.cc -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Sun, 18 Nov 2018 11:23:18 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-cip-c: H</span><br><span class="line"></span><br><span class="line">IP: 153.3.0.xx</span><br><span class="line">地址: 中国 xx  xx</span><br><span class="line">运营商: 联通</span><br><span class="line"></span><br><span class="line">数据二: 江苏省xx市 | 联通</span><br><span class="line"></span><br><span class="line">数据三: 中国江苏省xx市 | 联通</span><br><span class="line"></span><br><span class="line">URL: http://www.cip.cc/153.3.0.xx</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;那如果想不输入完整的指令，而想直接加个参数，如加个<code>-i</code>就可以显示 HTTP 头信息，该怎么办呢？那就要用到下一个命令<code>ENTRYPOINT</code> 入口点了</p><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>&emsp;&emsp;当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;    //命令变为参数传给ENTRYPOINT</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;还是举前面的查公网IP的例子，将Dockerfile更改为：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"><span class="keyword">RUN</span> apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y curl \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT ["curl","-s","cip.cc"]</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>build</code> 镜像命名为<code>curl_entrypoint</code>,运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm curl_entrypoint:latest           </span><br><span class="line">IP: 153.3.0.xx</span><br><span class="line">地址: 中国 xx  xx</span><br><span class="line">运营商: 联通</span><br><span class="line"></span><br><span class="line">数据二: 江苏省xx市 | 联通</span><br><span class="line"></span><br><span class="line">数据三: 中国江苏省xx市 | 联通</span><br><span class="line"></span><br><span class="line">URL: http://www.cip.cc/153.3.0.xx</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;那么加上参数<code>-i</code>呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm curl_entrypoint:latest -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Sun, 18 Nov 2018 11:57:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-cip-c: H</span><br><span class="line"></span><br><span class="line">IP: 153.3.0.xx</span><br><span class="line">地址: 中国 xx  xx</span><br><span class="line">运营商: 联通</span><br><span class="line"></span><br><span class="line">数据二: 江苏省xx市 | 联通</span><br><span class="line"></span><br><span class="line">数据三: 中国江苏省xx市 | 联通</span><br><span class="line"></span><br><span class="line">URL: http://www.cip.cc/153.3.0.xx</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;由此可以看出<code>CMD</code>命令和<code>ENTRYPOINT</code>入口点的区别</p><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>&emsp;&emsp;这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">eg:ENV NODE_VERSION 7.2.0</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br><span class="line">eg:ENV VERSION=1.0 DEBUG=on NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure></p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>&emsp;&emsp;之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span> /data</span><br></pre></td></tr></table></figure></p><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式为 <span class="keyword">EXPOSE</span> &lt;端口<span class="number">1</span>&gt; [&lt;端口<span class="number">2</span>&gt;...]。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 <code>Dockerfile</code> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>&emsp;&emsp;要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h2 id="7-挂载主机目录"><a href="#7-挂载主机目录" class="headerlink" title="7.挂载主机目录"></a>7.挂载主机目录</h2><p>&emsp;&emsp;使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v /src/webapp:/opt/webapp \</span><br><span class="line">    --mount type=bind,source=/src/webapp,target=/opt/webapp \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用<code>-v /src/webapp:/opt/webapp</code>是之前的一种挂载的方法。上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 –mount 参数时如果本地目录不存在，Docker 会报错。</p><p>&emsp;&emsp;Docker 挂载主机目录的默认权限是<font color="Violet" size="3px">读写</font>，用户也可以通过增加 readonly 指定为 <font color="Violet" size="3px">只读</font>。<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v /src/webapp:/opt/webapp:ro \</span><br><span class="line">    --mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样权限就变为只读了，在容器内部创建文件会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;现今容器化技术对于技术行业的改变是非常巨大的，特别是对于企业来说，因此学习掌握容器化技术的基础是非常必要的。&lt;/p&gt;
&lt;h2 id=&quot;1-docker安装&quot;&gt;&lt;a href=&quot;#1-docker安装&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="技术工具" scheme="http://xiexuliunian.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>git命令</title>
    <link href="http://xiexuliunian.github.io/2018/11/15/git%E5%91%BD%E4%BB%A4/"/>
    <id>http://xiexuliunian.github.io/2018/11/15/git命令/</id>
    <published>2018-11-15T21:21:33.000Z</published>
    <updated>2019-03-01T14:31:02.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a><center>git常用命令</center></h1><ul><li>以下是一些学习工作中常用的git操作，以供记录使用。</li></ul><h2 id="1-初始化仓库"><a href="#1-初始化仓库" class="headerlink" title="1.初始化仓库"></a>1.初始化仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>在当前目录下创建.git目录，同时当前目录成为一个Git仓库,意味着当前目录下的文件状态的改变，会被git记录</p><h2 id="2-从远程仓库克隆"><a href="#2-从远程仓库克隆" class="headerlink" title="2.从远程仓库克隆"></a>2.从远程仓库克隆</h2><p><code>git clone [git仓库url]</code>将http或ssh链接指向的Git仓库拷贝到本地，默认是master分支。</p><p><code>git clone -b [分支名] [git仓库url]</code>则克隆的是该分支的仓库内容。</p><h2 id="3-增加、注释操作"><a href="#3-增加、注释操作" class="headerlink" title="3.增加、注释操作"></a>3.增加、注释操作</h2><p>有很多的工具可以更方便的添加和注释，不必要非要使用代码。</p><h2 id="4-当前状态"><a href="#4-当前状态" class="headerlink" title="4.当前状态"></a>4.当前状态</h2><p><code>git status</code>：显示当前仓库的最新状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">位于分支 hexo</span><br><span class="line">您的分支与上游分支 &apos;origin/hexo&apos; 一致。</span><br><span class="line"></span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">修改：     db.json</span><br><span class="line">修改：     package-lock.json</span><br><span class="line">修改：     package.json</span><br><span class="line"></span><br><span class="line">未跟踪的文件:</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容）</span><br><span class="line"></span><br><span class="line">&quot;source/_posts/git\345\221\275\344\273\244.md&quot;</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure></p><h2 id="5-git日志"><a href="#5-git日志" class="headerlink" title="5.git日志"></a>5.git日志</h2><p><code>git log</code>：显示从最近到最远的提交日志。包含每个提交的SHA1校验和、作者的名字和邮箱、提交时间以及提交说明等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">commit 67c8e0708bb198789df2896dfb47dcb27db7c564</span><br><span class="line">Author: xiexuliunian &lt;zzuzxd@126.com&gt;</span><br><span class="line">Date:   Fri Oct 26 21:14:49 2018 +0800</span><br><span class="line"></span><br><span class="line">    添加CI</span><br><span class="line"></span><br><span class="line">commit 918fa11a2a6f43736ea2716e5458b611d8998e22</span><br><span class="line">Merge: e2cb954 bd6c67c</span><br><span class="line">Author: xiexuliunian &lt;zzuzxd@126.com&gt;</span><br><span class="line">Date:   Fri Oct 26 20:33:42 2018 +0800</span><br></pre></td></tr></table></figure></p><h2 id="6-拉取操作"><a href="#6-拉取操作" class="headerlink" title="6.拉取操作"></a>6.拉取操作</h2><p><code>git pull</code>:拉取远程仓库最新提交，并合并到指定的本地分支上。</p><p><code>git fetch</code>:拉取远程仓库最新提交，但不会自动合并分支。</p><h2 id="7-推送操作"><a href="#7-推送操作" class="headerlink" title="7.推送操作"></a>7.推送操作</h2><p><code>git push</code>：将本地分支更改推送到远程仓库。</p><p>如果你是一个人这个操作，一般不会有问题，但是如果是多人协作一个项目，这一步很可能会有问题，原因是别人更新的新代码，你本地没有，因此下面操作是每次<code>push</code>前尽量遵循的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash       //暂存你本地的所有更改，使本地相对与上次pull是一个干净的环境。</span><br><span class="line">git pull        //拉取远程的仓库。</span><br><span class="line">git stash pop   //在上次拉取的新的代码上合并暂存的代码。</span><br><span class="line">git push        /现在你就可以放心的push代码了。</span><br></pre></td></tr></table></figure></p><h2 id="8-当你push出错的时候"><a href="#8-当你push出错的时候" class="headerlink" title="8.当你push出错的时候"></a>8.当你push出错的时候</h2><p>当多人合作时，如果你push之前没有pull那么你很有可能会遇到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &apos;https://github.com/dummymare/Hello-World.git&apos;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &apos;git pull ...&apos;) before pushing again.</span><br><span class="line">hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure></p><p>使用<code>git pull --rebase</code>：–rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中。</p><p>常用的解决方案是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash           </span><br><span class="line">git pull --rebase   </span><br><span class="line">git stash pop       </span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git常用命令&quot;&gt;&lt;a href=&quot;#git常用命令&quot; class=&quot;headerlink&quot; title=&quot;git常用命令&quot;&gt;&lt;/a&gt;&lt;center&gt;git常用命令&lt;/center&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;以下是一些学习工作中常用的git操作，以供记录使用。&lt;
      
    
    </summary>
    
      <category term="技术工具" scheme="http://xiexuliunian.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Lsoftmax</title>
    <link href="http://xiexuliunian.github.io/2018/11/12/Lsoftmax/"/>
    <id>http://xiexuliunian.github.io/2018/11/12/Lsoftmax/</id>
    <published>2018-11-12T22:52:30.000Z</published>
    <updated>2019-03-01T14:31:02.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lsoftmax论文笔记"><a href="#Lsoftmax论文笔记" class="headerlink" title="Lsoftmax论文笔记"></a><center>Lsoftmax论文笔记</center></h1><p>TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lsoftmax论文笔记&quot;&gt;&lt;a href=&quot;#Lsoftmax论文笔记&quot; class=&quot;headerlink&quot; title=&quot;Lsoftmax论文笔记&quot;&gt;&lt;/a&gt;&lt;center&gt;Lsoftmax论文笔记&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;TODO&lt;/p&gt;

      
    
    </summary>
    
      <category term="论文" scheme="http://xiexuliunian.github.io/categories/%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Archlinux 安装配置美化</title>
    <link href="http://xiexuliunian.github.io/2018/04/05/Archlinux-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%BE%8E%E5%8C%96/"/>
    <id>http://xiexuliunian.github.io/2018/04/05/Archlinux-安装配置美化/</id>
    <published>2018-04-05T17:24:48.000Z</published>
    <updated>2019-03-01T14:31:02.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Archlinux-安装配置美化"><a href="#Archlinux-安装配置美化" class="headerlink" title="Archlinux 安装配置美化"></a><center>Archlinux 安装配置美化</center></h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>很早之前，大概两三年前吧，第一次听说Archlinux,于是弄了个虚拟机开始了装机之路，折腾了两天，总算在虚拟机第一次装成功了，但是完成之后，记得使用的是gnome的桌面，什么都不会配置，一看这是什么呀，这么丑，哈哈是的仅仅是看看Archlinux完成之后是什么样子，结果大失所望，这比ubuntu的桌面还不如，折腾了两天是图啥呀，于是不再这上面投入时间了。前些天装了个manjaro的linux系统是基于Archlinux的发行版，虽然遇到点困难，但完成后给我真的是一种惊艳的感觉，操作感真的是棒棒哒，但是当我敲出<code>screenfetch</code>出现的是类似小米的丑陋图标时，我觉得既然manjaro是基于Archlinux的给人一种耳目一新的感觉，为什么我不从头开始搭建一个Archlinux，然后配置成类似的样子呢，所以一切是为了得到一张牛逼的图片，哈哈。</p><center><img src="/2018/04/05/Archlinux-安装配置美化/1.png" title="说明"></center><h2 id="1-系统安装"><a href="#1-系统安装" class="headerlink" title="1. 系统安装"></a>1. 系统安装</h2><h2 id="注意：本机为GPT-UEFI类型"><a href="#注意：本机为GPT-UEFI类型" class="headerlink" title="注意：本机为GPT+UEFI类型"></a>注意：本机为GPT+UEFI类型</h2><p>一切从下图开始</p><center><img src="/2018/04/05/Archlinux-安装配置美化/2.gif" title="说明"></center><h2 id="设置键盘布局"><a href="#设置键盘布局" class="headerlink" title="设置键盘布局"></a>设置键盘布局</h2><p>ArchISO 默认键盘布局为 US（美式键盘）。<br>如需修改键盘布局请使用 loadkeys 命令。<br>如需修改字体请使用 setfont 命令。</p><h2 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h2><p>ArchISO 在启动时会尝试连接网络，可通过命令 ping 查看连接是否已建立。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 www.baidu.com</span><br></pre></td></tr></table></figure></p><center><img src="/2018/04/05/Archlinux-安装配置美化/3.gif" title="说明"></center><p>若网络尚未连接，请先接入网络。若使用 WiFi 连接，请使用 wifi-menu 命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure></p><h2 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h2><p>同步时间以确保时间准确无误：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure></p><h2 id="选择软件仓库服务器"><a href="#选择软件仓库服务器" class="headerlink" title="选择软件仓库服务器"></a>选择软件仓库服务器</h2><blockquote><p>该配置不仅会应用到安装环境，也会应用至新系统中。</p></blockquote><p>选择地理位置最为接近的镜像服务器以获得更高的下载速度。pacman 优先使用位置靠前的镜像地址。将选定的镜像地址置于最前以便 pacman 使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><ol><li>[F6] 搜索 china</li><li>[方向键] 移动光标至 Server 行</li><li>[CTRL+K] 剪切该行</li><li>[方向键] 移动光标至其他 Server 行前</li><li>[CTRL+U] 粘贴至此行</li><li>[CTRL+O] 保存，[回车键] 确定</li><li>[CTRL+X] 推出<center><img src="/2018/04/05/Archlinux-安装配置美化/4.gif" title="说明"></center></li></ol><blockquote><p>本文选择zzu镜像<br><code>Server = http://mirrors.zzu.edu.cn/archlinux/$repo/os/$arch</code>比较快一点</p></blockquote><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h2 id="这是最关键的地方之一"><a href="#这是最关键的地方之一" class="headerlink" title="这是最关键的地方之一"></a>这是最关键的地方之一</h2><h2 id="分区方案"><a href="#分区方案" class="headerlink" title="分区方案"></a>分区方案</h2><ul><li><p>Arch Linux 要求至少一个分区分配给根目录 /。</p></li><li><p>在 UEFI 系统上，需要一个 UEFI 系统分区。(由于本文是双系统，Windows上已有该分区在/dev/sda2上)</p></li></ul><p>在本文的安装中，空闲磁盘100GB,分区如下：</p><table><thead><tr><th style="text-align:left">Linux Swap</th><th style="text-align:center">8GB</th><th style="text-align:right">/dev/sda9</th></tr></thead><tbody><tr><td style="text-align:left">/</td><td style="text-align:center">42GB</td><td style="text-align:right">/dev/sda10</td></tr><tr><td style="text-align:left">home</td><td style="text-align:center">50GB</td><td style="text-align:right">/dev/sda11</td></tr></tbody></table><p>使用gdisk很好对系统进行分区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdisk /dev/sda</span><br></pre></td></tr></table></figure></p><h2 id="格式化（创建文件系统）"><a href="#格式化（创建文件系统）" class="headerlink" title="格式化（创建文件系统）"></a>格式化（创建文件系统）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda9</span><br><span class="line">mkfs.ext4 /dev/sda10</span><br><span class="line">mkfs.ext4 /dev/sda11</span><br></pre></td></tr></table></figure><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda10 /mnt</span><br><span class="line">mkdir /mnt/home</span><br><span class="line">mkdir /mnt/boot/efi</span><br><span class="line">mount /dev/sda2 /mnt/boot/efi</span><br><span class="line">mount /dev/sda11 /mnt/home</span><br><span class="line"></span><br><span class="line">swapon /dev/sda9</span><br></pre></td></tr></table></figure><h2 id="安装基础包"><a href="#安装基础包" class="headerlink" title="安装基础包"></a>安装基础包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel</span><br></pre></td></tr></table></figure><h2 id="生成分区表"><a href="#生成分区表" class="headerlink" title="生成分区表"></a>生成分区表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><h2 id="接着使用-arch-chroot-进入新系统。"><a href="#接着使用-arch-chroot-进入新系统。" class="headerlink" title="接着使用 arch-chroot 进入新系统。"></a>接着使用 arch-chroot 进入新系统。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt /bin/bash</span><br></pre></td></tr></table></figure><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><h2 id="区域设置"><a href="#区域设置" class="headerlink" title="区域设置"></a>区域设置</h2><p>进行区域设置以正确显示本地文字、货币、时间与时期格式以及其它本地相关标准。<br>编辑 /etc/locale.gen，去掉需要的 locale 的注释（行头的字符 #）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/locale.gen</span><br></pre></td></tr></table></figure><p>取消<code>en_US.UTF-8 UTF-8</code>上的注释，然后使用 locale-gen 生成 locale。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure></p><p>接着使用以下命令设置默认 locale。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure></p><h2 id="硬件时间设置"><a href="#硬件时间设置" class="headerlink" title="硬件时间设置"></a>硬件时间设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc --utc</span><br></pre></td></tr></table></figure><h2 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo zxd &gt; /etc/hostname</span><br></pre></td></tr></table></figure><p>接着向 /etc/hosts 文件添加 hosts 条目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&lt;ip-address&gt;&lt;hostname.domain.org&gt;&lt;hostname&gt;</span><br><span class="line">127.0.0.1localhost.localdomainlocalhost</span><br><span class="line">::1localhost.localdomain   localhost</span><br><span class="line">127.0.1.1zxd.localdomain        zxd</span><br></pre></td></tr></table></figure></p><h2 id="随机盘环境初始化"><a href="#随机盘环境初始化" class="headerlink" title="随机盘环境初始化"></a>随机盘环境初始化</h2><p>可能会有一些提示信息，安装过显卡驱动就可一了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkinitcpio -p linux</span><br></pre></td></tr></table></figure></p><h2 id="为-root-用户设置密码"><a href="#为-root-用户设置密码" class="headerlink" title="为 root 用户设置密码"></a>为 root 用户设置密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><h2 id="设置网络连接"><a href="#设置网络连接" class="headerlink" title="设置网络连接"></a>设置网络连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S iw wpa_supplicant networkmanager dialog</span><br><span class="line"></span><br><span class="line">systemctl enable NetworkManager</span><br></pre></td></tr></table></figure><h2 id="安装引导程序"><a href="#安装引导程序" class="headerlink" title="安装引导程序"></a>安装引导程序</h2><p>本文推荐 GRUB 作为引导程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syu grub efibootmgr</span><br><span class="line">pacman -Syu efibootmgr</span><br><span class="line">grub-mkconfig -o boot/grub/grub.cfg</span><br><span class="line">grub-install /dev/sda</span><br></pre></td></tr></table></figure></p><h2 id="退出Chroot"><a href="#退出Chroot" class="headerlink" title="退出Chroot"></a>退出Chroot</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">unount -R /mnt</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="ok，到此我们已经得到了命令行版的Archlinux"><a href="#ok，到此我们已经得到了命令行版的Archlinux" class="headerlink" title="ok，到此我们已经得到了命令行版的Archlinux"></a>ok，到此我们已经得到了命令行版的Archlinux</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Archlinux-安装配置美化&quot;&gt;&lt;a href=&quot;#Archlinux-安装配置美化&quot; class=&quot;headerlink&quot; title=&quot;Archlinux 安装配置美化&quot;&gt;&lt;/a&gt;&lt;center&gt;Archlinux 安装配置美化&lt;/center&gt;&lt;/h1&gt;
      
    
    </summary>
    
      <category term="linux" scheme="http://xiexuliunian.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>rEFInd安装及配置</title>
    <link href="http://xiexuliunian.github.io/2018/03/30/rEFInd%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <id>http://xiexuliunian.github.io/2018/03/30/rEFInd安装及配置/</id>
    <published>2018-03-30T09:36:39.000Z</published>
    <updated>2019-03-01T14:31:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rEFInd安装及配置"><a href="#rEFInd安装及配置" class="headerlink" title="rEFInd安装及配置"></a><center>rEFInd安装及配置</center></h1><h2 id="注意-rEFInd引导项仅支持EFI引导模式，对传统的BIOS引导不支持"><a href="#注意-rEFInd引导项仅支持EFI引导模式，对传统的BIOS引导不支持" class="headerlink" title="注意  rEFInd引导项仅支持EFI引导模式，对传统的BIOS引导不支持"></a><code>注意</code>  rEFInd引导项仅支持EFI引导模式，对传统的BIOS引导不支持</h2><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>本机使用的是manjaro archlinux 发行版，在安装rEFInd上比较方便，直接 <a href="https://sourceforge.net/projects/refind/" title="这是rEFInd的源码连接" target="_blank" rel="noopener">源码</a>，得到一个<code>refind-bin-0.11.2.zip</code>的压缩包，解压后转到该文件夹下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x refind-install //为安装文件赋予权限</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./refind-install //安装</span><br></pre></td></tr></table></figure><p>ok，就这么简单咯，就可以使用<code>rEFInd</code>接管丑陋的<code>grub</code>开机引导界面了</p><h2 id="2-主题美化"><a href="#2-主题美化" class="headerlink" title="2.主题美化"></a>2.主题美化</h2><p>然而我们发现基本的rEFInd引导界面也不是很好看，为它换个主题吧。看中了这个主题。<a href="https://github.com/EvanPurkhiser/rEFInd-minimal" title="这是该主题的github页面" target="_blank" rel="noopener">github页面</a></p><center><img src="/2018/03/30/rEFInd安装及配置/1.png" title="说明"></center><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><blockquote><p>1.安装好rEFInd后，首先定位到计算机的refind EFI目录，一般在<code>/boot/EFI/refind（注意进入到该目标需要首先进入管理员身份su才行)目录下</code></p><p>2.在该文件夹下建立<code>themes</code>文件夹</p><p>3.将该主题<code>clone</code>到<code>themes</code>文件夹,在<code>themes</code>文件夹下输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/EvanPurkhiser/rEFInd-minimal.git</span><br></pre></td></tr></table></figure></p><p>4.为了使该主题生效，需要将<code>include themes/rEFInd-minimal/theme.conf</code>语句添加到配置文件<code>refind.conf</code>中去</p></blockquote><p>ok,重启吧。看看新的主题。</p><h2 id="3-rEFInd-卸载"><a href="#3-rEFInd-卸载" class="headerlink" title="3. rEFInd 卸载"></a>3. rEFInd 卸载</h2><p>想卸载rEFInd，没问题，很简单哟。在管理员权限下运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r /boot/efi/EFI/refind</span><br></pre></td></tr></table></figure></p><p>重启你就会看到久违的grub引导界面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rEFInd安装及配置&quot;&gt;&lt;a href=&quot;#rEFInd安装及配置&quot; class=&quot;headerlink&quot; title=&quot;rEFInd安装及配置&quot;&gt;&lt;/a&gt;&lt;center&gt;rEFInd安装及配置&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;注意-rEFInd引导项
      
    
    </summary>
    
      <category term="linux" scheme="http://xiexuliunian.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>manjaro配置及美化</title>
    <link href="http://xiexuliunian.github.io/2018/03/23/manjaro%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BE%8E%E5%8C%96/"/>
    <id>http://xiexuliunian.github.io/2018/03/23/manjaro配置及美化/</id>
    <published>2018-03-23T14:52:44.000Z</published>
    <updated>2019-03-01T14:31:02.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="manjaro-麻将-配置及美化"><a href="#manjaro-麻将-配置及美化" class="headerlink" title="manjaro(麻将)配置及美化"></a><center>manjaro(麻将)配置及美化</center></h1><p>manjaro是一款基于archlinux的linux发行版，以前主要用<code>ubuntu</code>系统的，主要用来使用CUDA的，在ubuntu上的安装过程十分痛苦，第一次使用manjaro,在其上的安装过程让我惊叹，这么好用呀，所以就迷上了这款系统。</p><h2 id="1-系统安装"><a href="#1-系统安装" class="headerlink" title="1. 系统安装"></a>1. 系统安装</h2><ul><li><p>在制作启动盘时，使用其他的启动盘制作都会无法进行安装，使用rufus这款软件，以DD模式写入才可以安装。</p></li><li><p>跟在ubuntu上的安装过程十分类似，都是图形界面的，但是有一点，注意要在win10的EFI分区(本机是/dev/sda2 上选择<code>/boot/efi</code>标记),其余都是类似的，点下一步就ok了</p></li></ul><h2 id="2-系统更新及软件安装"><a href="#2-系统更新及软件安装" class="headerlink" title="2.系统更新及软件安装"></a>2.系统更新及软件安装</h2><h2 id="更换中国源"><a href="#更换中国源" class="headerlink" title="更换中国源"></a>更换中国源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -c China  //选择中国源  </span><br><span class="line">sudo pacman -Syyu  //更新系统</span><br></pre></td></tr></table></figure><h2 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h2><p>打开终端输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/pacman.conf</span><br></pre></td></tr></table></figure></p><p>在文件底部加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Optional TrustedOnly</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>然后执行<br><code>sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</code><br>之后就可以从包管理器中搜索安装各种软件了enjoying，部分软件仍然需要配置，如搜狗输入法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-sogoupinyin</span><br><span class="line">sudo pacman -S fcitx-im  #全部安装</span><br><span class="line">suao pacman -S fcitx-configtool  #图形化配置工具</span><br></pre></td></tr></table></figure></p><p>需要设置输入法变量<br><code>sudo gedit ~/.profile(有可能是.xprofile)</code>,在其底部加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=”@im=fcitx”</span><br></pre></td></tr></table></figure></p><p>如果还是不行的话，在/etc/profile文件中加入上述指令</p><p>另外一个安装是使用AUR源，首先安装yaourt</p><p><code>sudo pacman -S yaourt</code></p><p>修改<code>/etc/yaourtrc</code>,去掉<code># AURURL</code>的注释，修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AURURL=&quot;https://aur.tuna.tsinghua.edu.cn&quot;</span><br></pre></td></tr></table></figure></p><p>这样就可以使用AUR源了哟</p><h2 id="3-系统美化"><a href="#3-系统美化" class="headerlink" title="3. 系统美化"></a>3. 系统美化</h2><h2 id="来个配件大全"><a href="#来个配件大全" class="headerlink" title="来个配件大全"></a>来个配件大全</h2><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Application:<code>Arc</code></p><p>Cursor:<code>Xcursor-breeze</code></p><p>Icons:<code>Numix-Circle-Light</code></p><p>Shell:<code>Adapta-Nokto-Eta-Maia</code></p><h2 id="下面放美图"><a href="#下面放美图" class="headerlink" title="下面放美图"></a>下面放美图</h2><div style="width: 90%; margin: auto"><br><center><img src="/2018/03/23/manjaro配置及美化/1.png" title="说明"></center><br></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;manjaro-麻将-配置及美化&quot;&gt;&lt;a href=&quot;#manjaro-麻将-配置及美化&quot; class=&quot;headerlink&quot; title=&quot;manjaro(麻将)配置及美化&quot;&gt;&lt;/a&gt;&lt;center&gt;manjaro(麻将)配置及美化&lt;/center&gt;&lt;/h1&gt;
      
    
    </summary>
    
      <category term="linux" scheme="http://xiexuliunian.github.io/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql数据库</title>
    <link href="http://xiexuliunian.github.io/2018/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://xiexuliunian.github.io/2018/03/15/数据库/</id>
    <published>2018-03-15T10:36:49.000Z</published>
    <updated>2019-03-01T14:31:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库学习"><a href="#数据库学习" class="headerlink" title="数据库学习"></a><center>数据库学习</center></h1><h2 id="1-建立一个新库"><a href="#1-建立一个新库" class="headerlink" title="1.建立一个新库"></a>1.建立一个新库</h2><p><code>create database db1;</code></p><p>注意有冒号的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database db1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure></p><h2 id="2-查看现有库"><a href="#2-查看现有库" class="headerlink" title="2.查看现有库"></a>2.查看现有库</h2><p><code>show databases;</code>有冒号，复数形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| db1                |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| world              |</span><br><span class="line">+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h2 id="3-销毁一个库"><a href="#3-销毁一个库" class="headerlink" title="3.销毁一个库"></a>3.销毁一个库</h2><p><code>drop datebase db1;</code>再显示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sakila             |</span><br><span class="line">| sys                |</span><br><span class="line">| world              |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>接续</p><p>基本验证了可以使用不同的主机进行hexo博客的书写。</p><p>啦啦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库学习&quot;&gt;&lt;a href=&quot;#数据库学习&quot; class=&quot;headerlink&quot; title=&quot;数据库学习&quot;&gt;&lt;/a&gt;&lt;center&gt;数据库学习&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-建立一个新库&quot;&gt;&lt;a href=&quot;#1-建立一个新库&quot; class=
      
    
    </summary>
    
      <category term="数据库" scheme="http://xiexuliunian.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown 语法说明</title>
    <link href="http://xiexuliunian.github.io/2017/12/14/Markdown-%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8E/"/>
    <id>http://xiexuliunian.github.io/2017/12/14/Markdown-语法说明/</id>
    <published>2017-12-14T13:21:12.000Z</published>
    <updated>2019-03-01T14:31:02.292Z</updated>
    
    <content type="html"><![CDATA[<center>Markdownd的语法说明</center><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><p>分段的情况空一行即可</p><h1 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h1><p><code>*你好*</code>表示效果： <em>你好</em> ，是斜体的</p><p><code>_你好_</code>也是表示斜体的：<em>你好</em></p><p><code>**你好**</code>显示的是粗体效果：<strong>你好</strong></p><p><code>~~你好~~</code>显示划线文本：<del>你好</del></p><p>I end with two spaces (highlight me to see them).</p><p>There’s a <br> above me!</p><p>块引用很容易，用<code>&gt;</code>完成，如下</p><blockquote><p>这是一个块</p><p>这也是一个块</p><blockquote><p>这是什么呢？两个块</p></blockquote></blockquote><h1 id="无序列表和有序列表"><a href="#无序列表和有序列表" class="headerlink" title="无序列表和有序列表"></a>无序列表和有序列表</h1><ul><li>开头一个星号，然后空格</li></ul><ul><li>或者一个加号</li></ul><ul><li>或者一个减号<h2 id="下面是有序列表"><a href="#下面是有序列表" class="headerlink" title="下面是有序列表"></a>下面是有序列表</h2></li></ul><ol><li>你好</li><li>hello</li><li>哈哈<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 你好</span><br><span class="line">2. hello</span><br><span class="line">3. 哈哈</span><br></pre></td></tr></table></figure></li></ol><h2 id="子列表"><a href="#子列表" class="headerlink" title="子列表"></a>子列表</h2><ol><li>啦啦啦</li><li>哈哈哈</li><li>哇哇哇<ul><li>一二</li><li>三四</li></ul></li><li>厉害了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 啦啦啦</span><br><span class="line">2. 哈哈哈</span><br><span class="line">3. 哇哇哇</span><br><span class="line">    * 一二</span><br><span class="line">    * 三四</span><br><span class="line">4. 厉害了</span><br></pre></td></tr></table></figure><h1 id="插入连接和代码"><a href="#插入连接和代码" class="headerlink" title="插入连接和代码"></a>插入连接和代码</h1><p>本文的<a href="https://github.com/xiexuliunian" title="这是我的个人github主页哟" target="_blank" rel="noopener">Github</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文的[Github](https://github.com/xiexuliunian &quot;这是我的个人github主页哟&quot;)</span><br></pre></td></tr></table></figure></p><p>对图片的引用格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片名字](网址)</span><br></pre></td></tr></table></figure></p><div style="width: 200px; margin: auto"><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1513240842596&amp;di=3f709ec01342b92906b56d3e4fcad471&amp;imgtype=0&amp;src=http%3A%2F%2Fimg5.duitang.com%2Fuploads%2Fitem%2F201407%2F30%2F20140730143346_MUG4w.thumb.700_0.jpeg" alt="陌上花开"></div><p>分割线可以为<code>***</code>或者<code>---</code></p><hr><hr><p>Boxes below without the ‘x’ are unchecked HTML checkboxes.</p><ul><li style="list-style: none"><input type="checkbox"> First task to complete.</li><li style="list-style: none"><input type="checkbox"> Second task that needs done<br>This checkbox below will be a checked HTML checkbox.</li><li style="list-style: none"><input type="checkbox" checked> This task has been completed</li></ul><p>选框代码如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Boxes below without the 'x' are unchecked HTML checkboxes.</span><br><span class="line">- [ ] First task to complete.</span><br><span class="line">- [ ] Second task that needs done</span><br><span class="line">This checkbox below will be a checked HTML checkbox.</span><br><span class="line">- [x] This task has been completed</span><br></pre></td></tr></table></figure><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>可以使用四个空格，或一个制表符表示</p><pre><code>啦啦啦</code></pre><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foobar</span></span></span><br><span class="line">    puts <span class="string">"Hello world!"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://www.baidu.com/" title="这是一个百度链接" target="_blank" rel="noopener">Click me!</a></p><p><code>[Click me!](http://www.baidu.com/ &quot;这是一个百度链接&quot;)</code></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a><br><a href="www.baidu.com">百度</a></p><h2 id="自动电子邮件"><a href="#自动电子邮件" class="headerlink" title="自动电子邮件"></a>自动电子邮件</h2><p><a href="zzuzxd@126.com">邮箱</a></p><h2 id="表示键盘按键"><a href="#表示键盘按键" class="headerlink" title="表示键盘按键"></a>表示键盘按键</h2><p>Your computer crashed? Try sending a<br><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></p><p><code>Your computer crashed? Try sending a&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;</code></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th style="text-align:left">你好</th><th style="text-align:center">啦啦</th><th style="text-align:right">呼呼</th></tr></thead><tbody><tr><td style="text-align:left">左</td><td style="text-align:center">中</td><td style="text-align:right">右</td></tr><tr><td style="text-align:left">一</td><td style="text-align:center">二</td><td style="text-align:right">三</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;Markdownd的语法说明&lt;/center&gt;

&lt;h1 id=&quot;标题1&quot;&gt;&lt;a href=&quot;#标题1&quot; class=&quot;headerlink&quot; title=&quot;标题1&quot;&gt;&lt;/a&gt;标题1&lt;/h1&gt;&lt;h2 id=&quot;标题2&quot;&gt;&lt;a href=&quot;#标题2&quot; class=&quot;h
      
    
    </summary>
    
      <category term="技术工具" scheme="http://xiexuliunian.github.io/categories/%E6%8A%80%E6%9C%AF%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>vscode python 配置环境</title>
    <link href="http://xiexuliunian.github.io/2017/12/07/vscode-python-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
    <id>http://xiexuliunian.github.io/2017/12/07/vscode-python-配置环境/</id>
    <published>2017-12-07T09:19:09.000Z</published>
    <updated>2019-03-01T14:31:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vscode-python-的配置环境"><a href="#vscode-python-的配置环境" class="headerlink" title="vscode python 的配置环境"></a><center>vscode python 的配置环境</center></h1><ul><li>以下的配置仅针对，python vscode <h2 id="第一步，安装好vscode-安装好python"><a href="#第一步，安装好vscode-安装好python" class="headerlink" title="第一步，安装好vscode,安装好python"></a>第一步，安装好vscode,安装好python</h2><h2 id="第二步，在vscode中配置自己安装的python环境，由于我的环境采用了python虚拟环境，需要在vscode中说明。在设置的python-configration中进行设置。如下图"><a href="#第二步，在vscode中配置自己安装的python环境，由于我的环境采用了python虚拟环境，需要在vscode中说明。在设置的python-configration中进行设置。如下图" class="headerlink" title="第二步，在vscode中配置自己安装的python环境，由于我的环境采用了python虚拟环境，需要在vscode中说明。在设置的python configration中进行设置。如下图"></a>第二步，在vscode中配置自己安装的python环境，由于我的环境采用了python虚拟环境，需要在vscode中说明。在设置的python configration中进行设置。如下图</h2><center><img src="/2017/12/07/vscode-python-配置环境/1.png" title="说明"></center></li></ul><h2 id="这里设置是，python的虚拟环境绝对路径，尽量不要添加空格，本文中由于之前添加空格了，如图，由于许多的开发环境都在里面，就很难改了。"><a href="#这里设置是，python的虚拟环境绝对路径，尽量不要添加空格，本文中由于之前添加空格了，如图，由于许多的开发环境都在里面，就很难改了。" class="headerlink" title="这里设置是，python的虚拟环境绝对路径，尽量不要添加空格，本文中由于之前添加空格了，如图，由于许多的开发环境都在里面，就很难改了。"></a>这里设置是，python的虚拟环境绝对路径，尽量不要添加空格，本文中由于之前添加空格了，如图，由于许多的开发环境都在里面，就很难改了。</h2><center><img src="/2017/12/07/vscode-python-配置环境/2.png" title="说明"></center><h2 id="第三步，在vscode中新建一个python文件，按ctrl-shift-B来运行的话，会让你配置一个tasks-json的文件，由于有两个版本，这里就放两种写法。"><a href="#第三步，在vscode中新建一个python文件，按ctrl-shift-B来运行的话，会让你配置一个tasks-json的文件，由于有两个版本，这里就放两种写法。" class="headerlink" title="第三步，在vscode中新建一个python文件，按ctrl+shift+B来运行的话，会让你配置一个tasks.json的文件，由于有两个版本，这里就放两种写法。"></a>第三步，在vscode中新建一个python文件，按<code>ctrl</code>+<code>shift</code>+<code>B</code>来运行的话，会让你配置一个<code>tasks.json</code>的文件，由于有两个版本，这里就放两种写法。</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">// "windows": &#123;</span><br><span class="line">// "command": "python"</span><br><span class="line">    // &#125;,</span><br><span class="line">// "command": "$&#123;config:python.pythonPath&#125;",</span><br><span class="line">"command": "python",</span><br><span class="line">"isShellCommand": true,</span><br><span class="line">"showOutput": "always",</span><br><span class="line">"args": ["$&#123;file&#125;"],</span><br><span class="line">"options": &#123;</span><br><span class="line">        "env": &#123;</span><br><span class="line">            "PYTHONIOENCODING": "UTF-8"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// &#123;</span><br><span class="line">//     // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">//     // for the documentation about the tasks.json format</span><br><span class="line">//     "version": "2.0.0",</span><br><span class="line">//     "tasks": [</span><br><span class="line">//         &#123;</span><br><span class="line">//             "label": "Run Python Code",</span><br><span class="line">//             "type": "shell",</span><br><span class="line">//             "command": "python",</span><br><span class="line">//             "args": [</span><br><span class="line">//                 "'$&#123;file&#125;'"</span><br><span class="line">//             ],</span><br><span class="line">//             "group": &#123;</span><br><span class="line">//                 "kind": "build",</span><br><span class="line">//                 "isDefault": true</span><br><span class="line">//             &#125;,</span><br><span class="line">//             "presentation": &#123;</span><br><span class="line">//                 "echo": true,</span><br><span class="line">//                 "reveal": "always",</span><br><span class="line">//                 "focus": true,</span><br><span class="line">//                 "panel": "shared"</span><br><span class="line">//             &#125;</span><br><span class="line">//         &#125;</span><br><span class="line">//     ]</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><ul><li>注意，请尽量不要在绝对路径里面加空格，不然很麻烦。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vscode-python-的配置环境&quot;&gt;&lt;a href=&quot;#vscode-python-的配置环境&quot; class=&quot;headerlink&quot; title=&quot;vscode python 的配置环境&quot;&gt;&lt;/a&gt;&lt;center&gt;vscode python 的配置环境&lt;/
      
    
    </summary>
    
      <category term="python基础知识" scheme="http://xiexuliunian.github.io/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树遍历顺序</title>
    <link href="http://xiexuliunian.github.io/2017/11/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F/"/>
    <id>http://xiexuliunian.github.io/2017/11/22/二叉树遍历顺序/</id>
    <published>2017-11-22T10:28:28.000Z</published>
    <updated>2019-03-01T14:31:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树遍历顺序"><a href="#二叉树遍历顺序" class="headerlink" title="二叉树遍历顺序"></a><center>二叉树遍历顺序</center></h1><ul><li>第一种：<code>先序遍历</code><br>遍历的顺序是根-&gt;左-&gt;右，如图1</li></ul><div style="width: 50%; margin: auto"><br><center><img src="/2017/11/22/二叉树遍历顺序/1.jpg" title="[图1]"></center><br></div><ul><li><p>第二种：<code>中序遍历</code><br>遍历顺序是左-&gt;根-&gt;右，如图2</p><div style="width: 50%; margin: auto"><br><center><img src="/2017/11/22/二叉树遍历顺序/2.jpg" title="[图2]"></center><br></div></li><li><p>第三种：<code>后序遍历</code><br>遍历顺序是左-&gt;右-&gt;根，如图3</p><div style="width: 50%; margin: auto"><br><center><img src="/2017/11/22/二叉树遍历顺序/3.jpg" title="[图3]"></center><br></div></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉树遍历顺序&quot;&gt;&lt;a href=&quot;#二叉树遍历顺序&quot; class=&quot;headerlink&quot; title=&quot;二叉树遍历顺序&quot;&gt;&lt;/a&gt;&lt;center&gt;二叉树遍历顺序&lt;/center&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;第一种：&lt;code&gt;先序遍历&lt;/code&gt;&lt;br&gt;遍历
      
    
    </summary>
    
      <category term="数据结构" scheme="http://xiexuliunian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Argparse 笔记</title>
    <link href="http://xiexuliunian.github.io/2017/11/19/Argparse-%E7%AC%94%E8%AE%B0/"/>
    <id>http://xiexuliunian.github.io/2017/11/19/Argparse-笔记/</id>
    <published>2017-11-19T11:54:58.000Z</published>
    <updated>2019-03-01T14:31:02.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Argparse学习笔记"><a href="#1-Argparse学习笔记" class="headerlink" title="1.Argparse学习笔记"></a><center>1.Argparse学习笔记</center></h2><h3 id="在学习python的时候，经常遇到下面的语句。"><a href="#在学习python的时候，经常遇到下面的语句。" class="headerlink" title="在学习python的时候，经常遇到下面的语句。"></a>在学习python的时候，经常遇到下面的语句。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>:</span><br><span class="line">    parser=argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--number1'</span>,help=<span class="string">'第一个数字'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--number2'</span>,help=<span class="string">'第二个数字'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--operation'</span>,help=<span class="string">'操作符'</span>)</span><br><span class="line"></span><br><span class="line">    args=parser.parse_args()</span><br></pre></td></tr></table></figure><p><font color="red" size="3px">这些是什么呢？</font>  我们来看下定义，argparse是python用于解析命令行参数和选项的标准模块，用于代替已经过时的optparse模块。argparse模块的作用是用于解析命令行参数，例如python parseTest.py input.txt output.txt –user=name –port=8080。</p><h2 id="第一步设置一个解析器"><a href="#第一步设置一个解析器" class="headerlink" title="第一步设置一个解析器"></a><font color="#4590a3" size="4px">第一步设置一个解析器</font></h2><ul><li><p>使用argparse的第一步就是创建一个解析器对象，并告诉它将会有些什么参数。那么当你的程序运行时，该解析器就可以用于处理命令行参数。解析器类是 ArgumentParser 。构造方法接收几个参数来设置用于程序帮助文本的描述信息以及其他全局的行为或设置。</p></li><li><p><code>parser=argparse.ArgumentParser()</code> 这句代码用来设置解析器</p><h2 id="第二步-定义参数"><a href="#第二步-定义参数" class="headerlink" title="第二步 定义参数"></a><font color="#4590a3" size="4px">第二步 定义参数</font></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--number1'</span>,help=<span class="string">'第一个数字'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--number2'</span>,help=<span class="string">'第二个数字'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--operation'</span>,help=<span class="string">'操作符'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>这里添加参数，我们来看下运行结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>:</span><br><span class="line">    parser=argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'number1'</span>,help=<span class="string">'第一个数字'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'number2'</span>,help=<span class="string">'第二个数字'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'operation'</span>,help=<span class="string">'操作符'</span>)</span><br><span class="line"></span><br><span class="line">    args=parser.parse_args()</span><br><span class="line"></span><br><span class="line">    print(args.number1)</span><br><span class="line">    print(args.number2)</span><br><span class="line">    print(args.operation)</span><br><span class="line"></span><br><span class="line">    n1=int(args.number1)</span><br><span class="line">    n2=int(args.number2)</span><br><span class="line">    result=<span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> args.operation == <span class="string">"+"</span>:</span><br><span class="line">        print(<span class="string">'结果是：%d'</span>%(n1+n2))</span><br></pre></td></tr></table></figure></p><p>输入命令<code>python demo.py -h</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usage: fmt output.py [-h] number1 number2 operation</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  number1     第一个数字</span><br><span class="line">  number2     第二个数字</span><br><span class="line">  operation   操作符</span><br></pre></td></tr></table></figure></p><p>输入命令 <code>pthon demo 2 5 +</code>,结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">+</span><br><span class="line">结果是：7</span><br></pre></td></tr></table></figure></p><p>将上述源码做一下改动<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--number1'</span>,help=<span class="string">'第一个数字'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--number2'</span>,help=<span class="string">'第二个数字'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--operation'</span>,help=<span class="string">'操作符'</span>)</span><br></pre></td></tr></table></figure></p><p>输入命令<code>python demo.py -h</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">usage: fmt output.py [-h] [--number1 NUMBER1] [--number2 NUMBER2]</span><br><span class="line">                     [--operation OPERATION]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  --number1 NUMBER1     第一个数字</span><br><span class="line">  --number2 NUMBER2     第二个数字</span><br><span class="line">  --operation OPERATION   操作符</span><br></pre></td></tr></table></figure></p><ul><li>我们可以看到不一致，此时的调用可以采用<code>python demo --number 2 --number 5 --operation +</code>来输入</li></ul><h2 id="2-这是第二次写Argparse这个模块，Anyway，那就写的深入点吧"><a href="#2-这是第二次写Argparse这个模块，Anyway，那就写的深入点吧" class="headerlink" title="2.这是第二次写Argparse这个模块，Anyway，那就写的深入点吧"></a><center>2.这是第二次写Argparse这个模块，Anyway，那就写的深入点吧</center></h2><ul><li>今天我们这里主要来讲<code>add_argument()</code>这个方法，这也是Argparse这个模块里面使用最多的方法。</li></ul><h3 id="2-1-Name或者flags参数"><a href="#2-1-Name或者flags参数" class="headerlink" title="2.1 Name或者flags参数"></a>2.1 Name或者flags参数</h3><p>我们使用<code>add_argument()</code>来创建新的参数的时候，必须知道新的参数是位置参数还是可选参数，以及参数是否使用缩写。当我们创建位置参数时，可以创建如下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'inter'</span>)</span><br><span class="line">args=parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.inter)</span><br></pre></td></tr></table></figure></p><p>然后输入命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python argp.py 12</span><br></pre></td></tr></table></figure></p><p>传进去的参数12，就被赋给了<code>inter</code>,随后被打印出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS E:\codeme\python learn\VS code\python basic&gt; python .\argp.py -i 12</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p><p>接下来我们看，如何创建一个可选参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--inter'</span>)</span><br><span class="line">args=parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.inter)</span><br></pre></td></tr></table></figure></p><p>这时的命令该怎么输呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python argp.py --inter 12</span><br></pre></td></tr></table></figure></p><p>这样就可以了，之所以称其为可选参数，是因为如果你不传递参数进去，程序也不会报错，而之前的位置参数，当不传递参数进去时，就会报错了。<code>--inter</code>显然有些麻烦，那如何简写呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'-i'</span>,<span class="string">'--inter'</span>)</span><br><span class="line">args=parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.inter)</span><br></pre></td></tr></table></figure></p><p>这样输入<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python argp.py -i 12</span><br></pre></td></tr></table></figure></p><p>就仍然达到传递参数12进去的效果了。这就说明可选参数以<code>&#39;-&#39;</code>来表明，而其他的参数被认为是位置参数了。</p><h3 id="2-2-action参数"><a href="#2-2-action参数" class="headerlink" title="2.2 action参数"></a>2.2 action参数</h3><p><code>action</code> 关键字指出应该如何处理命令行参数</p><p><code>&#39;store&#39;</code>只是保存参数，是默认的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--inter'</span>)</span><br><span class="line">args=parser.parse_args([<span class="string">'--inter'</span>,<span class="string">'12'</span>])</span><br><span class="line"></span><br><span class="line">print(args.inter)</span><br></pre></td></tr></table></figure></p><p>输出为 <code>12</code></p><p><code>&#39;store_const&#39;</code>保存const关键字指出的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--inter'</span>,action=<span class="string">'store_const'</span>,const=<span class="number">23</span>)</span><br><span class="line">args=parser.parse_args([<span class="string">'--inter'</span>])</span><br><span class="line"></span><br><span class="line">print(args.inter)</span><br></pre></td></tr></table></figure></p><p>输出为 <code>23</code></p><p><code>&#39;store_true&#39;</code>和<code>&#39;store_false&#39;</code> - 它们是<code>&#39;store_const&#39;</code>的特殊情形，分别用于保存值True和False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--inter'</span>,action=<span class="string">'store_true'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--float'</span>,action=<span class="string">'store_false'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--double'</span>,action=<span class="string">'store_false'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args=parser.parse_args([<span class="string">'--inter'</span>,<span class="string">'--float'</span>])</span><br><span class="line"></span><br><span class="line">print(args.inter,args.float,args.double)</span><br></pre></td></tr></table></figure></p><p>输出 <code>True False True</code></p><p><code>&#39;append&#39;</code> - 保存一个列表，并将每个参数值附加在列表的后面。这对于允许指定多次的选项很有帮助。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--inter'</span>,action=<span class="string">'append'</span>)</span><br><span class="line">args=parser.parse_args([<span class="string">'--inter'</span>,<span class="string">'12'</span>,<span class="string">'--inter'</span>,<span class="string">'45'</span>])</span><br><span class="line"></span><br><span class="line">print(args.inter)</span><br></pre></td></tr></table></figure></p><p>这里由于<code>--inter</code>可以调用多次，将后面的数字加到其列表里，所以输出为<code>[&#39;12&#39;, &#39;45&#39;]</code></p><p><code>&#39;append_const&#39;</code> - 保存一个列表，并将const关键字参数指出的值附加在列表的后面。（注意const关键字参数默认是None。）<code>&#39;append_const&#39;</code> 动作在多个参数需要保存常量到相同的列表时特别有用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--inter'</span>,dest=<span class="string">'types'</span>,action=<span class="string">'append_const'</span>,const=int)</span><br><span class="line">parser.add_argument(<span class="string">'--float'</span>,dest=<span class="string">'types'</span>,action=<span class="string">'append_const'</span>,const=float)</span><br><span class="line"></span><br><span class="line">args=parser.parse_args([<span class="string">'--inter'</span>,<span class="string">'--float'</span>])</span><br><span class="line"></span><br><span class="line">print(args.types)</span><br></pre></td></tr></table></figure></p><p>输出 <code>[&lt;class &#39;int&#39;&gt;, &lt;class &#39;float&#39;&gt;]</code></p><p><code>&#39;count&#39;</code> - 计算关键字参数出现的次数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--inter'</span>,<span class="string">'-i'</span>,action=<span class="string">'count'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args=parser.parse_args([<span class="string">'-iii'</span>])</span><br><span class="line"></span><br><span class="line">print(args.inter)</span><br><span class="line">args=parser.parse_args([<span class="string">'-iiiiii'</span>])</span><br><span class="line">print(args.inter)</span><br></pre></td></tr></table></figure></p><p>输出为 <code>3 6</code></p><h3 id="2-3-nargs参数"><a href="#2-3-nargs参数" class="headerlink" title="2.3 nargs参数"></a>2.3 nargs参数</h3><p><code>nargs</code>关键字参数将一个动作(<code>action</code>)与不同数目的命令行参数关联在一起。</p><blockquote><p>它的值首先可以是一个整数 <strong><code>N</code></strong></p></blockquote><ul><li>我们先来看一个默认的情况, 没有nargs参数：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line">args=parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.foo)</span><br></pre></td></tr></table></figure></li></ul><p>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python args.py --foo 2</span><br></pre></td></tr></table></figure></p><p>结果为 <strong><code>2</code></strong></p><ul><li>再来看一个具有nargs参数的情况  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>,nargs=<span class="number">2</span>)</span><br><span class="line">args=parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.foo)</span><br></pre></td></tr></table></figure></li></ul><p>这里 <code>nargs=2</code> ,规定可以传递两个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python args.py --foo 2 3</span><br></pre></td></tr></table></figure></p><p>来看一下输出<br><code>[&#39;2&#39;, &#39;3&#39;]</code>,是一个列表，而之前的是元素本身。</p><blockquote><p><code>nargs</code>的值可以是 <strong><code>？</code></strong>,如果有的话就从命令行读取一个参数并生成一个元素。如果没有对应的命令行参数，则产生一个来自default的值。注意，对于可选参数，有另外一种情况 - 有选项字符串但是后面没有跟随命令行参数。在这种情况下，将生成一个来自const的值</p></blockquote><ul><li>来看一个有参数的情况<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>,nargs=<span class="string">"?"</span>)</span><br><span class="line">args=parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.foo)</span><br></pre></td></tr></table></figure></li></ul><p>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python args.py --foo 2</span><br></pre></td></tr></table></figure></p><p>结果为 <strong><code>2</code></strong></p><ul><li>没有参数时<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>,nargs=<span class="string">"?"</span>,default=<span class="string">'2'</span>,const=<span class="string">'3'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'int'</span>,nargs=<span class="string">'?'</span>,default=<span class="string">'z'</span>)</span><br><span class="line">args=parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.foo,args.int)</span><br></pre></td></tr></table></figure></li></ul><p>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python args.py</span><br></pre></td></tr></table></figure></p><p>输出 <strong><code>2 z</code></strong></p><p>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python args.py y --foo</span><br></pre></td></tr></table></figure></p><p>输出 <strong><code>3 y</code></strong></p><p>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python args.py y --foo 5</span><br></pre></td></tr></table></figure></p><p>输出 <strong><code>5 y</code></strong></p><blockquote><p><code>nargs</code>的值可以是 <code>*</code>和 <code>+</code>, 出现的所有命令行参数都被收集到一个列表中。注意，一般情况下具有多个带有 <code>nargs=&#39;*&#39;</code>的位置参数是不合理的，但是多个带有 <code>nargs=&#39;*&#39;</code>的可选参数是可能的。<code>+</code>的情况下，如果没有至少出现一个命令行参数将会产生一个错误信息，<code>*</code>不会产生这个问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser=argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--bar'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'baz'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line">args=parser.parse_args()</span><br><span class="line">print(<span class="string">'args.foo=%6s'</span>%args.foo,<span class="string">'args.bar=%6s'</span>%args.bar,<span class="string">'args.baz=%6s'</span>%args.baz,sep=<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></p></blockquote><p>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python args.py a b --foo 2 3 --bar z s</span><br></pre></td></tr></table></figure></p><p>输出</p><p><code>args.foo=[&#39;2&#39;, &#39;3&#39;]</code></p><p><code>args.bar=[&#39;z&#39;, &#39;s&#39;]</code></p><p><code>args.baz=[&#39;a&#39;, &#39;b&#39;]</code></p><blockquote><p>如果没有提供 <code>nargs</code>关键字参数，读取的参数个数取决于<code>action</code>。通常这意味着将读取一个命令行参数并产生一个元素（不是一个列表）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Argparse学习笔记&quot;&gt;&lt;a href=&quot;#1-Argparse学习笔记&quot; class=&quot;headerlink&quot; title=&quot;1.Argparse学习笔记&quot;&gt;&lt;/a&gt;&lt;center&gt;1.Argparse学习笔记&lt;/center&gt;&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="python基础知识" scheme="http://xiexuliunian.github.io/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>python 学习笔记</title>
    <link href="http://xiexuliunian.github.io/2017/11/18/python%E7%AC%94%E8%AE%B0/"/>
    <id>http://xiexuliunian.github.io/2017/11/18/python笔记/</id>
    <published>2017-11-18T13:46:18.000Z</published>
    <updated>2019-03-01T14:31:02.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a><center>学习笔记</center></h1><h3 id="1-元组-tuple-里面的元素是不可以更改的，但是元组里面的列表中的元素是可以更改的。如下所示。"><a href="#1-元组-tuple-里面的元素是不可以更改的，但是元组里面的列表中的元素是可以更改的。如下所示。" class="headerlink" title="1. 元组(tuple)里面的元素是不可以更改的，但是元组里面的列表中的元素是可以更改的。如下所示。"></a>1. <font color="#4590a3" size="4px">元组(tuple)</font>里面的元素是不可以更改的，但是元组里面的列表中的元素是可以更改的。如下所示。</h3><center><img src="/2017/11/18/python笔记/1.png" title="说明"></center><h3 id="2-if-语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager："><a href="#2-if-语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager：" class="headerlink" title="2. if 语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager："></a>2. <font color="#4590a3" size="4px">if </font>语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure><h3 id="3-循环-我们可以轻易的实现一个100的求和。"><a href="#3-循环-我们可以轻易的实现一个100的求和。" class="headerlink" title="3.循环 我们可以轻易的实现一个100的求和。"></a>3.<font color="#4590a3" size="4px">循环 </font>我们可以轻易的实现一个100的求和。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    sum +=i</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h3 id="4-字典-dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。"><a href="#4-字典-dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。" class="headerlink" title="4.字典 dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。"></a>4.<font color="#4590a3" size="4px">字典 </font>dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure><p>和list比较，dict有以下几个特点：</p><p>查找和插入的速度极快，不会随着key的增加而变慢；</p><p>需要占用大量的内存，内存浪费多。</p><p>而list相反：</p><p>查找和插入的时间随着元素的增加而增加；<br>占用空间小，浪费内存很少。</p><font color="#4590a3" size="4px">Set(集合) </font> 也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。而且集合中的数据是无序的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><br><br><font color="#4590a3" size="4px">5 .Python中的Map函数 </font>  <p><code>map()</code>是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><code>[1, 4, 9, 10, 25, 36, 49, 64, 81]</code></p><p><font color="red" size="6px">任务 </font><br>&ensp;&ensp;&ensp;&ensp;假设用户输入的英文名字不规范，没有按照首字母大写，后续字母小写的规则，请利用map()函数，把一个list（包含若干不规范的英文名字）变成一个包含规范英文名字的list：  输入：[‘adam’, ‘LISA’, ‘barT’]<br>输出：[‘Adam’, ‘Lisa’, ‘Bart’]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_name</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="comment"># s=s[0].upper()+s[1:].lower()</span></span><br><span class="line">    <span class="comment"># s=s.capitalize()</span></span><br><span class="line">    s=s.title()</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">a=map(format_name,[<span class="string">'adam'</span>,<span class="string">'LISA'</span>,<span class="string">'barT'</span>])</span><br><span class="line">print(list(a))</span><br></pre></td></tr></table></figure><p>输出为：<code>[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习笔记&quot;&gt;&lt;a href=&quot;#学习笔记&quot; class=&quot;headerlink&quot; title=&quot;学习笔记&quot;&gt;&lt;/a&gt;&lt;center&gt;学习笔记&lt;/center&gt;&lt;/h1&gt;&lt;h3 id=&quot;1-元组-tuple-里面的元素是不可以更改的，但是元组里面的列表中的元素是可以
      
    
    </summary>
    
      <category term="python基础知识" scheme="http://xiexuliunian.github.io/categories/python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
</feed>
