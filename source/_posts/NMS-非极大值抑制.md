---
title: NMS 非极大值抑制
date: 2019-01-18 19:21:37
categories: 深度学习
---
# <center>NMS 非极大值抑制</center>
&emsp;&emsp;`非极大值抑制(NMS)`是目标检测、人脸检测中比较常用的一种去除重复目标框的算法，下面以人脸检测为例子，详细的对NMS算法进行分析。

&emsp;&emsp;首先来看一副没有经过极大值抑制的人脸检测的图片。

<div style="width: 60%; margin: auto">
<center>{% asset_img 111.png [NMS前效果] %}</center>
</div>
&emsp;&emsp;可以看到人脸周围有一些重复、混杂的候选框，这是我们不想看到的。

&emsp;&emsp;一般由模型生成的候选框格式为*Mx5*的矩阵如上图的13个候选框，可以表示为如下的矩阵。
```
[[605.81859586 241.9870858  700.2810722  364.39490232   0.99813652]
 [604.46993595 241.94542132 701.05659627 362.6476619    0.99952543]
 [607.75556511 242.27479172 700.98139177 361.36630836   0.99824369]
 [607.31619582 235.84528071 703.34242228 364.37593491   0.99813581]
 [391.33261696 232.13301024 503.14739725 368.47360138   0.99732131]
 [389.78343755 231.74821711 504.23048349 369.45828512   0.99716467]
 [149.77004275 265.61997575 257.41437337 382.3174709    0.99953663]
 [390.23283872 230.75751062 504.22839069 372.18188326   0.99547029]
 [391.34597505 232.12956198 504.59239189 368.02716969   0.99861956]
 [391.51429539 230.70551069 507.19974793 375.07921828   0.99901474]
 [389.82507351 230.74490997 502.93040028 373.79520297   0.99129468]
 [151.20828396 263.95166993 255.72295459 382.8332618    0.99350882]
 [390.00525969 227.63024712 504.61705256 378.54596627   0.99982077]]
```
&emsp;&emsp;分表表示候选框的左上、右下坐标点及置信概率p,表示为：`[x1,y1,x2,y2,p]`，NMS是如何对上述候选框进行处理的呢?看代码吧
```Python
ef nms(boxes, overlap_threshold=0.5, mode='union'):
    x1 = boxes[:, 0]        #矩形左上角的x坐标
    y1 = boxes[:, 1]        #矩形左上角的y坐标
    x2 = boxes[:, 2]        #矩形右下角的x坐标    
    y2 = boxes[:, 3]        #矩形右下角的y坐标
    scores = boxes[:, 4]    #矩形候选框的置信度

    areas = (x2 - x1 + 1) * (y2 - y1 + 1)   #计算每个矩阵候选框的面积，+1是为了数值稳定性
    order = scores.argsort()[::-1]
    #按置信度进行排序(从大到小)
    #返回值的索引[12  6  1  9  8  2  0  3  4  5  7 11 10]

    keep = []       #要保留的索引的列表
    while order.size > 0:
        i = order[0]        #取出置信度最大的索引
        keep.append(i)      #放在保留索引的列表中
        xx1 = np.maximum(x1[i], x1[order[1:]])  
        yy1 = np.maximum(y1[i], y1[order[1:]])
        xx2 = np.minimum(x2[i], x2[order[1:]])
        yy2 = np.minimum(y2[i], y2[order[1:]])
        #上述四句代码取选中的矩形框和其余的12个矩形框一一比对，取左上角坐标较大的和右下角坐标较小的。
        #如果两个矩形相交，则构成相交区域矩形的两个顶点

        w = np.maximum(0.0, xx2 - xx1 + 1)      #相交时宽是正值，不想交的话宽为0
        h = np.maximum(0.0, yy2 - yy1 + 1)      #相交时高是正值，不想交的话高为0
        inter = w * h           #计算交集的面积，不想交的话值为0

        if mode is 'min':
            ovr = inter / np.minimum(areas[i], areas[order[1:]])    #交集占较小面积的比例
        else:
            ovr = inter / (areas[i] + areas[order[1:]] - inter)     #交集占并集的比例
            #[0.         0.         0.92467885 0.89049933 0.         0.
            #0.         0.8821858  0.90842802 0.93252505 0.         0.93301262]

        inds = np.where(ovr <= overlap_threshold)[0]     #获取比例小于阈值的ovr的索引[ 0  1  4  5  6 10]
        order = order[inds + 1]                          #order的索引为ovr的索引+1 order[1 2 5 6 7 11]
        #order=[ 6  1  2  0  3 11]

    return keep
    # keep=[12 6 1]
    # boxes=boxes[keep]
    # [[390.00525969 227.63024712 504.61705256 378.54596627   0.99982077]
    # [149.77004275 265.61997575 257.41437337 382.3174709    0.99953663]
    # [604.46993595 241.94542132 701.05659627 362.6476619    0.99952543]]
```
&emsp;&emsp;经过NMS后的效果
<div style="width: 60%; margin: auto">
<center>{% asset_img 222.png [NMS后效果] %}</center>
</div>
